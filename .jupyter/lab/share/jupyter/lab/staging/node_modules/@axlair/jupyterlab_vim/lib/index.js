import { INotebookTracker } from '@jupyterlab/notebook';
import { ICodeMirror } from '@jupyterlab/codemirror';
import { ISettingRegistry } from '@jupyterlab/settingregistry';
import { VimCellManager } from './codemirrorCommands';
import { addJLabCommands } from './labCommands';
const PLUGIN_NAME = '@axlair/jupyterlab_vim';
const TOGGLE_ID = 'jupyterlab-vim:toggle';
let enabled = false;
/**
 * Initialization data for the jupyterlab_vim extension.
 */
const extension = {
    id: PLUGIN_NAME,
    autoStart: true,
    activate: activateCellVim,
    requires: [INotebookTracker, ICodeMirror, ISettingRegistry]
};
async function activateCellVim(app, tracker, jlabCodeMirror, settingRegistry) {
    // await app.restored;
    app.commands.addCommand(TOGGLE_ID, {
        label: 'Enable Notebook Vim mode',
        execute: () => {
            if (settingRegistry) {
                void settingRegistry.set(`${PLUGIN_NAME}:plugin`, 'enabled', !enabled);
            }
        },
        isToggled: () => enabled
    });
    const userKeybindings = (await settingRegistry.get(`${PLUGIN_NAME}:plugin`, 'extraKeybindings')).composite;
    // eslint-disable-next-line prettier/prettier
    const globalCodeMirror = jlabCodeMirror.CodeMirror;
    let cellManager = null;
    let escBinding = null;
    let hasEverBeenEnabled = false;
    cellManager = new VimCellManager({
        commands: app.commands,
        cm: globalCodeMirror,
        enabled,
        userKeybindings
    });
    // it's ok to connect here because we will never reach the vim section unless
    // ensureVimKeyMap has been called due to the checks for enabled.
    // we need to have now in order to keep track of the last active cell
    // so that we can modify it when vim is turned on or off.
    tracker.activeCellChanged.connect(cellManager.onActiveCellChanged, cellManager);
    addJLabCommands(app, tracker, globalCodeMirror);
    async function updateSettings(settings) {
        const userKeybindings = (await settingRegistry.get(`${PLUGIN_NAME}:plugin`, 'extraKeybindings')).composite;
        enabled = settings.get('enabled').composite === true;
        app.commands.notifyCommandChanged(TOGGLE_ID);
        if (cellManager) {
            cellManager.enabled = enabled;
            cellManager.userKeybindings = userKeybindings;
        }
        if (enabled) {
            escBinding === null || escBinding === void 0 ? void 0 : escBinding.dispose();
            if (!hasEverBeenEnabled) {
                hasEverBeenEnabled = true;
                await app.restored;
                await jlabCodeMirror.ensureVimKeymap();
            }
        }
        else {
            escBinding = app.commands.addKeyBinding({
                command: 'notebook:enter-command-mode',
                keys: ['Escape'],
                selector: '.jp-Notebook.jp-mod-editMode'
            });
        }
        tracker.forEach(notebook => {
            notebook.node.dataset.jpVimMode = `${enabled}`;
        });
        cellManager === null || cellManager === void 0 ? void 0 : cellManager.modifyCell(cellManager.lastActiveCell);
        // make sure our css selector is added to new notebooks
        tracker.widgetAdded.connect((sender, notebook) => {
            notebook.node.dataset.jpVimMode = `${enabled}`;
        });
    }
    settingRegistry.load(`${PLUGIN_NAME}:plugin`).then((settings) => {
        updateSettings(settings);
        settings.changed.connect(updateSettings);
    }, (err) => {
        console.error(`Could not load settings, so did not active ${PLUGIN_NAME}: ${err}`);
    });
    return Promise.resolve();
}
export default extension;
