{"version":3,"file":"vega-label.min.js","sources":["../src/util/markBitmaps.js","../src/util/Bitmap.js","../src/util/scaler.js","../src/util/placeAreaLabel/common.js","../src/util/placeAreaLabel/placeFloodFill.js","../src/util/placeMarkLabel.js","../src/LabelLayout.js","../src/util/placeAreaLabel/placeNaive.js","../src/util/placeAreaLabel/placeReducedSearch.js","../src/Label.js"],"sourcesContent":["import {canvas} from 'vega-canvas';\nimport {rederive} from 'vega-dataflow';\nimport {Marks} from 'vega-scenegraph';\n\n// bit mask for getting first 2 bytes of alpha value\nconst ALPHA_MASK = 0xff000000;\n\n// alpha value equivalent to opacity 0.0625\nconst INSIDE_OPACITY_IN_ALPHA = 0x10000000;\nconst INSIDE_OPACITY = 0.0625;\n\nexport function baseBitmaps($, data) {\n  const bitmap = $.bitmap();\n  // when there is no base mark but data points are to be avoided\n  (data || []).forEach(d => bitmap.set($(d.boundary[0]), $(d.boundary[3])));\n  return [bitmap, undefined];\n}\n\nexport function markBitmaps($, avoidMarks, labelInside, isGroupArea) {\n  // create canvas\n  const width = $.width,\n        height = $.height,\n        border = labelInside || isGroupArea,\n        context = canvas(width, height).getContext('2d');\n\n  // render all marks to be avoided into canvas\n  avoidMarks.forEach(items => draw(context, items, border));\n\n  // get canvas buffer, create bitmaps\n  const buffer = new Uint32Array(context.getImageData(0, 0, width, height).data.buffer),\n        layer1 = $.bitmap(),\n        layer2 = border && $.bitmap();\n\n  // populate bitmap layers\n  let x, y, u, v, alpha;\n  for (y=0; y < height; ++y) {\n    for (x=0; x < width; ++x) {\n      alpha = buffer[y * width + x] & ALPHA_MASK;\n      if (alpha) {\n        u = $(x);\n        v = $(y);\n        if (!isGroupArea) layer1.set(u, v); // update interior bitmap\n        if (border && alpha ^ INSIDE_OPACITY_IN_ALPHA) layer2.set(u, v); // update border bitmap\n      }\n    }\n  }\n\n  return [layer1, layer2];\n}\n\nfunction draw(context, items, interior) {\n  if (!items.length) return;\n  const type = items[0].mark.marktype;\n\n  if (type === 'group') {\n    items.forEach(group => {\n      group.items.forEach(mark => draw(context, mark.items, interior));\n    });\n  } else {\n    Marks[type].draw(context, {items: interior ? items.map(prepare) : items});\n  }\n}\n\n/**\n * Prepare item before drawing into canvas (setting stroke and opacity)\n * @param {object} source item to be prepared\n * @returns prepared item\n */\nfunction prepare(source) {\n  const item = rederive(source, {});\n\n  if (item.stroke) {\n    item.strokeOpacity = 1;\n  }\n\n  if (item.fill) {\n    item.fillOpacity = INSIDE_OPACITY;\n    item.stroke = '#000';\n    item.strokeOpacity = 1;\n    item.strokeWidth = 2;\n  }\n\n  return item;\n}\n","const DIV = 5,   // bit shift from x, y index to bit vector array index\n      MOD = 31,  // bit mask for index lookup within a bit vector\n      SIZE = 32, // individual bit vector size\n      RIGHT0 = new Uint32Array(SIZE + 1), // left-anchored bit vectors, full -> 0\n      RIGHT1 = new Uint32Array(SIZE + 1); // right-anchored bit vectors, 0 -> full\n\nRIGHT1[0] = 0;\nRIGHT0[0] = ~RIGHT1[0];\nfor (let i=1; i <= SIZE; ++i) {\n  RIGHT1[i] = (RIGHT1[i - 1] << 1) | 1;\n  RIGHT0[i] = ~RIGHT1[i];\n}\n\nexport default function(w, h) {\n  const array = new Uint32Array(~~((w * h + SIZE) / SIZE));\n\n  function _set(index, mask) {\n    array[index] |= mask;\n  }\n\n  function _clear(index, mask) {\n    array[index] &= mask;\n  }\n\n  return {\n    array: array,\n\n    get: (x, y) => {\n      const index = y * w + x;\n      return array[index >>> DIV] & (1 << (index & MOD));\n    },\n\n    set: (x, y) => {\n      const index = y * w + x;\n      _set(index >>> DIV, 1 << (index & MOD));\n    },\n\n    clear: (x, y) => {\n      const index = y * w + x;\n      _clear(index >>> DIV, ~(1 << (index & MOD)));\n    },\n\n    getRange: (x, y, x2, y2) => {\n      let r = y2, start, end, indexStart, indexEnd;\n      for (; r >= y; --r) {\n        start = r * w + x;\n        end = r * w + x2;\n        indexStart = start >>> DIV;\n        indexEnd = end >>> DIV;\n        if (indexStart === indexEnd) {\n          if (array[indexStart] & RIGHT0[start & MOD] & RIGHT1[(end & MOD) + 1]) {\n            return true;\n          }\n        } else {\n          if (array[indexStart] & RIGHT0[start & MOD]) return true;\n          if (array[indexEnd] & RIGHT1[(end & MOD) + 1]) return true;\n          for (let i = indexStart + 1; i < indexEnd; ++i) {\n            if (array[i]) return true;\n          }\n        }\n      }\n      return false;\n    },\n\n    setRange: (x, y, x2, y2) => {\n      let start, end, indexStart, indexEnd, i;\n      for (; y <= y2; ++y) {\n        start = y * w + x;\n        end = y * w + x2;\n        indexStart = start >>> DIV;\n        indexEnd = end >>> DIV;\n        if (indexStart === indexEnd) {\n          _set(indexStart, RIGHT0[start & MOD] & RIGHT1[(end & MOD) + 1]);\n        } else {\n          _set(indexStart, RIGHT0[start & MOD]);\n          _set(indexEnd, RIGHT1[(end & MOD) + 1]);\n          for (i = indexStart + 1; i < indexEnd; ++i) _set(i, 0xffffffff);\n        }\n      }\n    },\n\n    clearRange: (x, y, x2, y2) => {\n      let start, end, indexStart, indexEnd, i;\n      for (; y <= y2; ++y) {\n        start = y * w + x;\n        end = y * w + x2;\n        indexStart = start >>> DIV;\n        indexEnd = end >>> DIV;\n        if (indexStart === indexEnd) {\n          _clear(indexStart, RIGHT1[start & MOD] | RIGHT0[(end & MOD) + 1]);\n        } else {\n          _clear(indexStart, RIGHT1[start & MOD]);\n          _clear(indexEnd, RIGHT0[(end & MOD) + 1]);\n          for (i = indexStart + 1; i < indexEnd; ++i) _clear(i, 0);\n        }\n      }\n    },\n\n    outOfBounds: (x, y, x2, y2) => x < 0 || y < 0 || y2 >= h || x2 >= w\n  };\n}","import Bitmap from './Bitmap';\n\nexport default function(width, height, padding) {\n  const ratio = Math.max(1, Math.sqrt((width * height) / 1e6)),\n        w = ~~((width + 2 * padding + ratio) / ratio),\n        h = ~~((height + 2 * padding + ratio) / ratio),\n        scale = _ => ~~((_ + padding) / ratio);\n\n  scale.invert = _ => (_ * ratio) - padding;\n  scale.bitmap = () => Bitmap(w, h);\n  scale.ratio = ratio;\n  scale.padding = padding;\n  scale.width = width;\n  scale.height = height;\n\n  return scale;\n}","function outOfBounds(x, y, textWidth, textHeight, width, height) {\n  let r = textWidth / 2;\n  return x - r < 0\n      || x + r > width\n      || y - (r = textHeight / 2) < 0\n      || y + r > height;\n}\n\nfunction _outOfBounds() {\n  return false;\n}\n\nfunction collision($, x, y, textHeight, textWidth, h, bm0, bm1) {\n  const w = (textWidth * h) / (textHeight * 2),\n        x1 = $(x - w),\n        x2 = $(x + w),\n        y1 = $(y - (h = h/2)),\n        y2 = $(y + h);\n\n  return bm0.outOfBounds(x1, y1, x2, y2)\n      || bm0.getRange(x1, y1, x2, y2)\n      || (bm1 && bm1.getRange(x1, y1, x2, y2));\n}\n\nfunction _collision($, x, y, textHeight, textWidth, h, bm0, bm1) {\n  const w = (textWidth * h) / (textHeight * 2);\n  let x1 = $(x - w),\n      x2 = $(x + w),\n      y1 = $(y - (h = h/2)),\n      y2 = $(y + h);\n\n  x1 = x1 > 0 ? x1 : 0;\n  y1 = y1 > 0 ? y1 : 0;\n  x2 = x2 < $.width ? x2 : $.width - 1;\n  y2 = y2 < $.height ? y2 : $.height - 1;\n\n  return bm0.getRange(x1, y1, x2, y2) || (bm1 && bm1.getRange(x1, y1, x2, y2));\n}\n\nexport function getTests(infPadding) {\n  return infPadding\n    ? [_collision, _outOfBounds]\n    : [collision, outOfBounds];\n}","import {textMetrics} from 'vega-scenegraph';\nimport {getTests} from './common';\n\n// pixel direction offsets for flood fill search\nconst X_DIR = [-1, -1, 1, 1];\nconst Y_DIR = [-1, 1, -1, 1];\n\nexport default function($, bitmaps, avoidBaseMark, markIndex, infPadding) {\n  const width = $.width,\n      height = $.height,\n      [collision, outOfBounds] = getTests(infPadding),\n      bm0 = bitmaps[0], // where labels have been placed\n      bm1 = bitmaps[1], // area outlines\n      bm2 = $.bitmap(); // flood-fill visitations\n\n  // try to place a label within an input area mark\n  return function(d) {\n    const items = d.datum.datum.items[markIndex].items, // area points\n          n = items.length, // number of points\n          textHeight = d.datum.fontSize, // label width\n          textWidth = textMetrics.width(d.datum, d.datum.text), // label height\n          stack = []; // flood fill stack\n\n    let maxSize = avoidBaseMark ? textHeight : 0,\n        labelPlaced = false,\n        labelPlaced2 = false,\n        maxAreaWidth = 0,\n        x1, x2, y1, y2, x, y, _x, _y, lo, hi, mid, areaWidth;\n\n    // for each area sample point\n    for (let i=0; i<n; ++i) {\n      x1 = items[i].x;\n      y1 = items[i].y;\n      x2 = items[i].x2 === undefined ? x1 : items[i].x2;\n      y2 = items[i].y2 === undefined ? y1 : items[i].y2;\n\n      // add scaled center point to stack\n      stack.push([$((x1 + x2) / 2), $((y1 + y2) / 2)]);\n\n      // perform flood fill, visit points\n      while (stack.length) {\n        [_x, _y] = stack.pop();\n\n        // exit if point already marked\n        if (bm0.get(_x, _y) || bm1.get(_x, _y) || bm2.get(_x, _y)) continue;\n\n        // mark point in flood fill bitmap\n        // add search points for all (in bound) directions\n        bm2.set(_x, _y);\n        for (let j=0; j<4; ++j) {\n          x = _x + X_DIR[j];\n          y = _y + Y_DIR[j];\n          if (!bm2.outOfBounds(x, y, x, y)) stack.push([x, y]);\n        }\n\n        // unscale point back to x, y space\n        x = $.invert(_x);\n        y = $.invert(_y);\n        lo = maxSize;\n        hi = height; // TODO: make this bound smaller\n\n        if (\n          !outOfBounds(x, y, textWidth, textHeight, width, height) &&\n          !collision($, x, y, textHeight, textWidth, lo, bm0, bm1) &&\n          !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)\n        ) {\n          // if the label fits at the current sample point,\n          // perform binary search to find the largest font size that fits\n          while (hi - lo >= 1) {\n            mid = (lo + hi) / 2;\n            if (collision($, x, y, textHeight, textWidth, mid, bm0, bm1)) {\n              hi = mid;\n            } else {\n              lo = mid;\n            }\n          }\n          // place label if current lower bound exceeds prior max font size\n          if (lo > maxSize) {\n            d.x = x;\n            d.y = y;\n            maxSize = lo;\n            labelPlaced = true;\n          }\n        }\n      }\n\n      // place label at slice center if not placed through other means\n      // and if we're not avoiding overlap with other areas\n      if (!labelPlaced && !avoidBaseMark) {\n        // one span is zero, hence we can add\n        areaWidth = Math.abs(x2 - x1 + y2 - y1);\n        x = (x1 + x2) / 2;\n        y = (y1 + y2) / 2;\n\n        // place label if it fits and improves the max area width\n        if (\n          areaWidth >= maxAreaWidth &&\n          !outOfBounds(x, y, textWidth, textHeight, width, height) &&\n          !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)\n        ) {\n          maxAreaWidth = areaWidth;\n          d.x = x;\n          d.y = y;\n          labelPlaced2 = true;\n        }\n      }\n    }\n\n    // record current label placement information, update label bitmap\n    if (labelPlaced || labelPlaced2) {\n      x = textWidth / 2;\n      y = textHeight / 2;\n      bm0.setRange($(d.x - x), $(d.y - y), $(d.x + x), $(d.y + y));\n      d.align = 'center';\n      d.baseline = 'middle';\n      return true;\n    } else {\n      return false;\n    }\n  };\n}\n","import {textMetrics} from 'vega-scenegraph';\n\nconst Aligns = ['right', 'center', 'left'],\n      Baselines = ['bottom', 'middle', 'top'];\n\nexport default function($, bitmaps, anchors, offsets, infPadding) {\n  const width = $.width,\n        height = $.height,\n        bm0 = bitmaps[0],\n        bm1 = bitmaps[1],\n        n = offsets.length;\n\n  return function(d) {\n    const boundary = d.boundary,\n          textHeight = d.datum.fontSize;\n\n    // can not be placed if the mark is not visible in the graph bound\n    if (!infPadding && (boundary[2] < 0 || boundary[5] < 0 || boundary[0] > width || boundary[3] > height)) {\n      return false;\n    }\n\n    let textWidth = 0,\n        dx, dy, isInside, sizeFactor, insideFactor,\n        x1, x2, y1, y2, xc, yc,\n        _x1, _x2, _y1, _y2;\n\n    // for each anchor and offset\n    for (let i=0; i<n; ++i) {\n      dx = (anchors[i] & 0x3) - 1;\n      dy = ((anchors[i] >>> 0x2) & 0x3) - 1;\n\n      isInside = (dx === 0 && dy === 0) || offsets[i] < 0;\n      sizeFactor = dx && dy ? Math.SQRT1_2 : 1;\n      insideFactor = offsets[i] < 0 ? -1 : 1;\n\n      x1 = boundary[1 + dx] + offsets[i] * dx * sizeFactor;\n      yc = boundary[4 + dy] + (insideFactor * textHeight * dy) / 2 + offsets[i] * dy * sizeFactor;\n      y1 = yc - textHeight / 2;\n      y2 = yc + textHeight / 2;\n\n      _x1 = $(x1);\n      _y1 = $(y1);\n      _y2 = $(y2);\n\n      if (infPadding) {\n        _x1 = _x1 < 0 ? 0 : _x1;\n        _y1 = _y1 < 0 ? 0 : _y1;\n        _y2 = _y2 >= $.height ? ($.height - 1) : _y2;\n      }\n\n      if (!textWidth) {\n        // to avoid finding width of text label,\n        if (!test(_x1, _x1, _y1, _y2, bm0, bm1, x1, x1, y1, y2, boundary, isInside)) {\n          // skip this anchor/offset option if we fail to place a label with 1px width\n          continue;\n        } else {\n          // Otherwise, find the label width\n          textWidth = textMetrics.width(d.datum, d.datum.text);\n        }\n      }\n\n      xc = x1 + (insideFactor * textWidth * dx) / 2;\n      x1 = xc - textWidth / 2;\n      x2 = xc + textWidth / 2;\n\n      _x1 = $(x1);\n      _x2 = $(x2);\n\n      if (infPadding) {\n        _x1 = _x1 < 0 ? 0 : _x1;\n        _x2 = _x2 >= $.width ? ($.width - 1) : _x2;\n      }\n\n      if (test(_x1, _x2, _y1, _y2, bm0, bm1, x1, x2, y1, y2, boundary, isInside)) {\n        // place label if the position is placeable\n        d.x = !dx ? xc : dx * insideFactor < 0 ? x2 : x1;\n        d.y = !dy ? yc : dy * insideFactor < 0 ? y2 : y1;\n\n        d.align = Aligns[dx * insideFactor + 1];\n        d.baseline = Baselines[dy * insideFactor + 1];\n\n        bm0.setRange(_x1, _y1, _x2, _y2);\n        return true;\n      }\n    }\n\n    return false;\n  };\n}\n\n// Test if a label with the given dimensions can be added without overlap\nfunction test(_x1, _x2, _y1, _y2, bm0, bm1, x1, x2, y1, y2, boundary, isInside) {\n  return !(\n    bm0.outOfBounds(_x1, _y1, _x2, _y2) ||\n    (isInside && bm1\n      ? bm1.getRange(_x1, _y1, _x2, _y2) || !isInMarkBound(x1, y1, x2, y2, boundary)\n      : bm0.getRange(_x1, _y1, _x2, _y2))\n  );\n}\n\nfunction isInMarkBound(x1, y1, x2, y2, boundary) {\n  return boundary[0] <= x1 && x2 <= boundary[2]\n      && boundary[3] <= y1 && y2 <= boundary[5];\n}\n","import {baseBitmaps, markBitmaps} from './util/markBitmaps';\nimport scaler from './util/scaler';\nimport placeAreaLabelNaive from './util/placeAreaLabel/placeNaive';\nimport placeAreaLabelReducedSearch from './util/placeAreaLabel/placeReducedSearch';\nimport placeAreaLabelFloodFill from './util/placeAreaLabel/placeFloodFill';\nimport placeMarkLabel from './util/placeMarkLabel';\n\n// 8-bit representation of anchors\nconst TOP    = 0x0,\n      MIDDLE = 0x4,\n      BOTTOM = 0x8,\n      LEFT   = 0x0,\n      CENTER = 0x1,\n      RIGHT  = 0x2;\n\n// Mapping from text anchor to number representation\nconst anchorCode = {\n  'top-left':     TOP + LEFT,\n  'top':          TOP + CENTER,\n  'top-right':    TOP + RIGHT,\n  'left':         MIDDLE + LEFT,\n  'middle':       MIDDLE + CENTER,\n  'right':        MIDDLE + RIGHT,\n  'bottom-left':  BOTTOM + LEFT,\n  'bottom':       BOTTOM + CENTER,\n  'bottom-right': BOTTOM + RIGHT\n};\n\nconst placeAreaLabel = {\n  'naive': placeAreaLabelNaive,\n  'reduced-search': placeAreaLabelReducedSearch,\n  'floodfill': placeAreaLabelFloodFill\n};\n\nexport default function(texts, size, compare, offset, anchor,\n  avoidMarks, avoidBaseMark, lineAnchor, markIndex, padding, method)\n{\n  // early exit for empty data\n  if (!texts.length) return texts;\n\n  const positions = Math.max(offset.length, anchor.length),\n        offsets = getOffsets(offset, positions),\n        anchors = getAnchors(anchor, positions),\n        marktype = markType(texts[0].datum),\n        grouptype = marktype === 'group' && texts[0].datum.items[markIndex].marktype,\n        isGroupArea = grouptype === 'area',\n        boundary = markBoundary(marktype, grouptype, lineAnchor, markIndex),\n        infPadding = padding === null || padding === Infinity,\n        $ = scaler(size[0], size[1], infPadding ? 0 : padding),\n        isNaiveGroupArea = isGroupArea && method === 'naive';\n\n  // prepare text mark data for placing\n  const data = texts.map(d => ({\n    datum: d,\n    opacity: 0,\n    x: undefined,\n    y: undefined,\n    align: undefined,\n    baseline: undefined,\n    boundary: boundary(d)\n  }));\n\n  let bitmaps;\n  if (!isNaiveGroupArea) {\n    // sort labels in priority order, if comparator is provided\n    if (compare) {\n      data.sort((a, b) => compare(a.datum, b.datum));\n    }\n\n    // flag indicating if label can be placed inside its base mark\n    let labelInside = false;\n    for (let i=0; i < anchors.length && !labelInside; ++i) {\n      // label inside if anchor is at center\n      // label inside if offset to be inside the mark bound\n      labelInside = anchors[i] === 0x5 || offsets[i] < 0;\n    }\n\n    // extract data information from base mark when base mark is to be avoided\n    // base mark is implicitly avoided if it is a group area\n    if (marktype && (avoidBaseMark || isGroupArea)) {\n      avoidMarks = [texts.map(d => d.datum)].concat(avoidMarks);\n    }\n\n    // generate bitmaps for layout calculation\n    bitmaps = avoidMarks.length\n      ? markBitmaps($, avoidMarks, labelInside, isGroupArea)\n      : baseBitmaps($, avoidBaseMark && data);\n  }\n\n  // generate label placement function\n  const place = isGroupArea\n    ? placeAreaLabel[method]($, bitmaps, avoidBaseMark, markIndex, infPadding)\n    : placeMarkLabel($, bitmaps, anchors, offsets, infPadding);\n\n  // place all labels\n  data.forEach(d => d.opacity = +place(d));\n\n  return data;\n}\n\nfunction getOffsets(_, count) {\n  const offsets = new Float64Array(count),\n        n = _.length;\n  for (let i=0; i<n; ++i) offsets[i] = _[i] || 0;\n  for (let i=n; i<count; ++i) offsets[i] = offsets[n - 1];\n  return offsets;\n}\n\nfunction getAnchors(_, count) {\n  const anchors = new Int8Array(count),\n        n = _.length;\n  for (let i=0; i<n; ++i) anchors[i] |= anchorCode[_[i]];\n  for (let i=n; i<count; ++i) anchors[i] = anchors[n - 1];\n  return anchors;\n}\n\nfunction markType(item) {\n  return item && item.mark && item.mark.marktype;\n}\n\n/**\n * Factory function for function for getting base mark boundary, depending\n * on mark and group type. When mark type is undefined, line or area: boundary\n * is the coordinate of each data point. When base mark is grouped line,\n * boundary is either at the beginning or end of the line depending on the\n * value of lineAnchor. Otherwise, use bounds of base mark.\n */\nfunction markBoundary(marktype, grouptype, lineAnchor, markIndex) {\n  const xy = d => [d.x, d.x, d.x, d.y, d.y, d.y];\n\n  if (!marktype) {\n    return xy; // no reactive geometry\n  }\n\n  else if (marktype === 'line' || marktype === 'area') {\n    return d => xy(d.datum);\n  }\n\n  else if (grouptype === 'line') {\n    return d => {\n      const items = d.datum.items[markIndex].items;\n      return xy(items.length\n        ? items[lineAnchor === 'start' ? 0 : items.length - 1]\n        : {x: NaN, y: NaN});\n    };\n  }\n\n  else {\n    return d => {\n      const b = d.datum.bounds;\n      return [b.x1, (b.x1 + b.x2) / 2, b.x2, b.y1, (b.y1 + b.y2) / 2, b.y2];\n    };\n  }\n}\n","import {textMetrics} from 'vega-scenegraph';\n\nexport default function($, bitmaps, avoidBaseMark, markIndex) {\n  const width = $.width,\n      height = $.height;\n  \n  // try to place a label within an input area mark\n  return function(d) {\n    const items = d.datum.datum.items[markIndex].items, // area points\n          n = items.length, // number of points\n          textHeight = d.datum.fontSize, // label width\n          textWidth = textMetrics.width(d.datum, d.datum.text); // label height\n\n    let maxAreaWidth = 0,\n        x1, x2, y1, y2, x, y, areaWidth;\n\n    // for each area sample point\n    for (let i=0; i<n; ++i) {\n      x1 = items[i].x;\n      y1 = items[i].y;\n      x2 = items[i].x2 === undefined ? x1 : items[i].x2;\n      y2 = items[i].y2 === undefined ? y1 : items[i].y2;\n      x = (x1 + x2) / 2;\n      y = (y1 + y2) / 2;\n\n      areaWidth = Math.abs(x2 - x1 + y2 - y1);\n      if (areaWidth >= maxAreaWidth) {\n        maxAreaWidth = areaWidth;\n        d.x = x;\n        d.y = y;\n      }\n    }\n\n    x = textWidth / 2;\n    y = textHeight / 2;\n    x1 = d.x - x;\n    x2 = d.x + x;\n    y1 = d.y - y;\n    y2 = d.y + y;\n\n    d.align = 'center';\n    if (x1 < 0 && x2 <= width) {\n      d.align = 'left';\n    } else if (0 <= x1 && width < x2) {\n      d.align = 'right';\n    }\n\n    d.baseline = 'middle';\n    if (y1 < 0 && y2 <= height) {\n      d.baseline = 'top';\n    } else if (0 <= y1 && height < y2) {\n      d.baseline = 'bottom';\n    }\n\n    return true;\n  };\n}\n","import {textMetrics} from 'vega-scenegraph';\nimport {getTests} from './common';\n\nexport default function($, bitmaps, avoidBaseMark, markIndex, infPadding) {\n  const width = $.width,\n      height = $.height,\n      [collision, outOfBounds] = getTests(infPadding),\n      bm0 = bitmaps[0], // where labels have been placed\n      bm1 = bitmaps[1]; // area outlines\n  \n  function tryLabel(_x, _y, maxSize, textWidth, textHeight) {\n    const x = $.invert(_x),\n          y = $.invert(_y);\n    let lo = maxSize,\n        hi = height,\n        mid;\n    if (\n      !outOfBounds(x, y, textWidth, textHeight, width, height) &&\n      !collision($, x, y, textHeight, textWidth, lo, bm0, bm1) &&\n      !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)\n    ) {\n      // if the label fits at the current sample point,\n      // perform binary search to find the largest font size that fits\n      while (hi - lo >= 1) {\n        mid = (lo + hi) / 2;\n        if (collision($, x, y, textHeight, textWidth, mid, bm0, bm1)) {\n          hi = mid;\n        } else {\n          lo = mid;\n        }\n      }\n      // place label if current lower bound exceeds prior max font size\n      if (lo > maxSize) {\n        return [x, y, lo, true];\n      }\n    }\n  }\n\n  // try to place a label within an input area mark\n  return function(d) {\n    const items = d.datum.datum.items[markIndex].items, // area points\n          n = items.length, // number of points\n          textHeight = d.datum.fontSize, // label width\n          textWidth = textMetrics.width(d.datum, d.datum.text); // label height\n\n    let maxSize = avoidBaseMark ? textHeight : 0,\n        labelPlaced = false,\n        labelPlaced2 = false,\n        maxAreaWidth = 0,\n        x1, x2, y1, y2, x, y, _x, _y, _x1, _xMid, _x2, _y1, _yMid, _y2, areaWidth, result, swapTmp;\n\n    // for each area sample point\n    for (let i=0; i<n; ++i) {\n      x1 = items[i].x;\n      y1 = items[i].y;\n      x2 = items[i].x2 === undefined ? x1 : items[i].x2;\n      y2 = items[i].y2 === undefined ? y1 : items[i].y2;\n\n      if (x1 > x2) {\n        swapTmp = x1;\n        x1 = x2;\n        x2 = swapTmp;\n      }\n\n      if (y1 > y2) {\n        swapTmp = y1;\n        y1 = y2;\n        y2 = swapTmp;\n      }\n\n      _x1 = $(x1);\n      _x2 = $(x2);\n      _xMid = ~~((_x1 + _x2) / 2);\n      _y1 = $(y1);\n      _y2 = $(y2);\n      _yMid = ~~((_y1 + _y2) / 2);\n\n      // search along the line from mid point between the 2 border to lower border\n      for (_x = _xMid; _x >= _x1; --_x) {\n        for (_y = _yMid; _y >= _y1; --_y) {\n          result = tryLabel(_x, _y, maxSize, textWidth, textHeight);\n          if (result) {\n            [d.x, d.y, maxSize, labelPlaced] = result;\n          }\n        }\n      }\n\n      // search along the line from mid point between the 2 border to upper border\n      for (_x = _xMid; _x <= _x2; ++_x) {\n        for (_y = _yMid; _y <= _y2; ++_y) {\n          result = tryLabel(_x, _y, maxSize, textWidth, textHeight);\n          if (result) {\n            [d.x, d.y, maxSize, labelPlaced] = result;\n          }\n        }\n      }\n\n      // place label at slice center if not placed through other means\n      // and if we're not avoiding overlap with other areas\n      if (!labelPlaced && !avoidBaseMark) {\n        // one span is zero, hence we can add\n        areaWidth = Math.abs(x2 - x1 + y2 - y1);\n        x = (x1 + x2) / 2;\n        y = (y1 + y2) / 2;\n\n        // place label if it fits and improves the max area width\n        if (\n          areaWidth >= maxAreaWidth &&\n          !outOfBounds(x, y, textWidth, textHeight, width, height) &&\n          !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)\n        ) {\n          maxAreaWidth = areaWidth;\n          d.x = x;\n          d.y = y;\n          labelPlaced2 = true;\n        }\n      }\n    }\n\n    // record current label placement information, update label bitmap\n    if (labelPlaced || labelPlaced2) {\n      x = textWidth / 2;\n      y = textHeight / 2;\n      bm0.setRange($(d.x - x), $(d.y - y), $(d.x + x), $(d.y + y));\n      d.align = 'center';\n      d.baseline = 'middle';\n      return true;\n    } else {\n      return false;\n    }\n  };\n}\n","import labelLayout from './LabelLayout';\nimport {Transform} from 'vega-dataflow';\nimport {array, error, inherits, isFunction} from 'vega-util';\n\nconst Output = [\n  'x',\n  'y',\n  'opacity',\n  'align',\n  'baseline'\n];\n\nconst Anchors = [\n  'top-left',\n  'left',\n  'bottom-left',\n  'top',\n  'bottom',\n  'top-right',\n  'right',\n  'bottom-right'\n];\n\n/**\n * Compute text label layout to annotate marks.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<number>} params.size - The size of the layout, provided as a [width, height] array.\n * @param {function(*,*): number} [params.sort] - An optional\n *   comparator function for sorting label data in priority order.\n * @param {Array<string>} [params.anchor] - Label anchor points relative to the base mark bounding box.\n *   The available options are 'top-left', 'left', 'bottom-left', 'top',\n *   'bottom', 'top-right', 'right', 'bottom-right', 'middle'.\n * @param {Array<number>} [params.offset] - Label offsets (in pixels) from the base mark bounding box.\n *   This parameter is parallel to the list of anchor points.\n * @param {number | null} [params.padding=0] - The amount (in pixels) that a label may exceed the layout size.\n *   If this parameter is null, a label may exceed the layout size without any boundary.\n * @param {string} [params.lineAnchor='end'] - For group line mark labels only, indicates the anchor\n *   position for labels. One of 'start' or 'end'.\n * @param {string} [params.markIndex=0] - For group mark labels only, an index indicating\n *   which mark within the group should be labeled.\n * @param {Array<number>} [params.avoidMarks] - A list of additional mark names for which the label\n *   layout should avoid overlap.\n * @param {boolean} [params.avoidBaseMark=true] - Boolean flag indicating if labels should avoid\n *   overlap with the underlying base mark being labeled.\n * @param {string} [params.method='naive'] - For area make labels only, a method for\n *   place labels. One of 'naive', 'reduced-search', or 'floodfill'.\n * @param {Array<string>} [params.as] - The output fields written by the transform.\n *   The default is ['x', 'y', 'opacity', 'align', 'baseline'].\n */\nexport default function Label(params) {\n  Transform.call(this, null, params);\n}\n\nLabel.Definition = {\n  type: 'Label',\n  metadata: { modifies: true },\n  params: [\n    { name: 'size', type: 'number', array: true, length: 2, required: true },\n    { name: 'sort', type: 'compare' },\n    { name: 'anchor', type: 'string', array: true, default: Anchors },\n    { name: 'offset', type: 'number', array: true, default: [1] },\n    { name: 'padding', type: 'number', default: 0, null: true },\n    { name: 'lineAnchor', type: 'string', values: ['start', 'end'], default: 'end' },\n    { name: 'markIndex', type: 'number', default: 0 },\n    { name: 'avoidBaseMark', type: 'boolean', default: true },\n    { name: 'avoidMarks', type: 'data', array: true },\n    { name: 'method', type: 'string', default: 'naive'},\n    { name: 'as', type: 'string', array: true, length: Output.length, default: Output }\n  ]\n};\n\ninherits(Label, Transform, {\n  transform(_, pulse) {\n    function modp(param) {\n      const p = _[param];\n      return isFunction(p) && pulse.modified(p.fields);\n    }\n\n    const mod = _.modified();\n    if (!(mod || pulse.changed(pulse.ADD_REM) || modp('sort'))) return;\n    if (!_.size || _.size.length !== 2) {\n      error('Size parameter should be specified as a [width, height] array.');\n    }\n\n    const as = _.as || Output;\n\n    // run label layout\n    labelLayout(\n      pulse.materialize(pulse.SOURCE).source || [],\n      _.size,\n      _.sort,\n      array(_.offset == null ? 1 : _.offset),\n      array(_.anchor || Anchors),\n      _.avoidMarks || [],\n      _.avoidBaseMark !== false,\n      _.lineAnchor || 'end',\n      _.markIndex || 0,\n      _.padding === undefined ? 0 : _.padding,\n      _.method || 'naive'\n    ).forEach(l => {\n      // write layout results to data stream\n      const t = l.datum;\n      t[as[0]] = l.x;\n      t[as[1]] = l.y;\n      t[as[2]] = l.opacity;\n      t[as[3]] = l.align;\n      t[as[4]] = l.baseline;\n    });\n\n    return pulse.reflow(mod).modifies(as);\n  }\n});\n"],"names":["markBitmaps","$","avoidMarks","labelInside","isGroupArea","width","height","border","context","canvas","getContext","forEach","items","draw","buffer","Uint32Array","getImageData","data","layer1","bitmap","layer2","x","y","u","v","alpha","set","interior","length","type","mark","marktype","group","Marks","map","prepare","source","item","rederive","stroke","strokeOpacity","fill","fillOpacity","strokeWidth","MOD","RIGHT0","SIZE","RIGHT1","i","padding","ratio","Math","max","sqrt","w","h","scale","_","invert","array","_set","index","mask","_clear","get","clear","getRange","x2","y2","start","end","indexStart","indexEnd","r","setRange","clearRange","outOfBounds","Bitmap","textWidth","textHeight","_outOfBounds","collision","bm0","bm1","x1","y1","_collision","getTests","infPadding","X_DIR","Y_DIR","Aligns","Baselines","test","_x1","_x2","_y1","_y2","boundary","isInside","isInMarkBound","anchorCode","TOP","MIDDLE","BOTTOM","placeAreaLabel","bitmaps","avoidBaseMark","markIndex","d","datum","n","fontSize","textMetrics","text","areaWidth","maxAreaWidth","undefined","abs","align","baseline","tryLabel","_x","_y","maxSize","mid","lo","hi","_xMid","_yMid","result","swapTmp","labelPlaced","labelPlaced2","bm2","stack","push","pop","j","texts","size","compare","offset","anchor","lineAnchor","method","positions","offsets","count","Float64Array","getOffsets","anchors","Int8Array","getAnchors","grouptype","xy","NaN","b","bounds","markBoundary","Infinity","scaler","isNaiveGroupArea","opacity","sort","a","concat","baseBitmaps","place","dx","dy","sizeFactor","insideFactor","xc","yc","SQRT1_2","placeMarkLabel","Output","Anchors","Label","params","Transform","call","this","Definition","metadata","modifies","name","required","default","null","values","transform","pulse","mod","modified","changed","ADD_REM","param","p","isFunction","fields","modp","error","as","labelLayout","materialize","SOURCE","l","t","reflow"],"mappings":"2cAkBO,SAASA,EAAYC,EAAGC,EAAYC,EAAaC,SAEhDC,EAAQJ,EAAEI,MACVC,EAASL,EAAEK,OACXC,EAASJ,GAAeC,EACxBI,EAAUC,SAAOJ,EAAOC,GAAQI,WAAW,MAGjDR,EAAWS,SAAQC,GAASC,EAAKL,EAASI,EAAOL,WAG3CO,EAAS,IAAIC,YAAYP,EAAQQ,aAAa,EAAG,EAAGX,EAAOC,GAAQW,KAAKH,QACxEI,EAASjB,EAAEkB,SACXC,EAASb,GAAUN,EAAEkB,aAGvBE,EAAGC,EAAGC,EAAGC,EAAGC,MACXH,EAAE,EAAGA,EAAIhB,IAAUgB,MACjBD,EAAE,EAAGA,EAAIhB,IAASgB,EACrBI,EAhCa,WAgCLX,EAAOQ,EAAIjB,EAAQgB,GACvBI,IACFF,EAAItB,EAAEoB,GACNG,EAAIvB,EAAEqB,GACDlB,GAAac,EAAOQ,IAAIH,EAAGC,GAC5BjB,GAlCoB,UAkCVkB,GAAiCL,EAAOM,IAAIH,EAAGC,UAK5D,CAACN,EAAQE,GAGlB,SAASP,EAAKL,EAASI,EAAOe,OACvBf,EAAMgB,OAAQ,aACbC,EAAOjB,EAAM,GAAGkB,KAAKC,SAEd,UAATF,EACFjB,EAAMD,SAAQqB,IACZA,EAAMpB,MAAMD,SAAQmB,GAAQjB,EAAKL,EAASsB,EAAKlB,MAAOe,QAGxDM,QAAMJ,GAAMhB,KAAKL,EAAS,CAACI,MAAOe,EAAWf,EAAMsB,IAAIC,GAAWvB,IAStE,SAASuB,EAAQC,SACTC,EAAOC,WAASF,EAAQ,WAE1BC,EAAKE,SACPF,EAAKG,cAAgB,GAGnBH,EAAKI,OACPJ,EAAKK,YAnEc,MAoEnBL,EAAKE,OAAS,OACdF,EAAKG,cAAgB,EACrBH,EAAKM,YAAc,GAGdN,EClFT,MACMO,EAAM,GAENC,EAAS,IAAI9B,YAAY+B,IACzBC,EAAS,IAAIhC,YAAY+B,IAE/BC,EAAO,GAAK,EACZF,EAAO,IAAME,EAAO,GACpB,IAAK,IAAIC,EAAE,EAAGA,GAND,KAMcA,EACzBD,EAAOC,GAAMD,EAAOC,EAAI,IAAM,EAAK,EACnCH,EAAOG,IAAMD,EAAOC,GCRP,WAAS3C,EAAOC,EAAQ2C,SAC/BC,EAAQC,KAAKC,IAAI,EAAGD,KAAKE,KAAMhD,EAAQC,EAAU,MACjDgD,MAAQjD,EAAQ,EAAI4C,EAAUC,GAASA,GACvCK,MAAQjD,EAAS,EAAI2C,EAAUC,GAASA,GACxCM,EAAQC,OAASA,EAAIR,GAAWC,UAEtCM,EAAME,OAASD,GAAMA,EAAIP,EAASD,EAClCO,EAAMrC,OAAS,IDIF,SAASmC,EAAGC,SACnBI,EAAQ,IAAI5C,gBAAgBuC,EAAIC,EAZ3B,IAAA,cAcFK,EAAKC,EAAOC,GACnBH,EAAME,IAAUC,WAGTC,EAAOF,EAAOC,GACrBH,EAAME,IAAUC,QAGX,CACLH,MAAOA,EAEPK,IAAK,CAAC3C,EAAGC,WACDuC,EAAQvC,EAAIgC,EAAIjC,SACfsC,EAAME,IA7BP,GA6ByB,IAAMA,EAAQjB,IAG/ClB,IAAK,CAACL,EAAGC,WACDuC,EAAQvC,EAAIgC,EAAIjC,EACtBuC,EAAKC,IAlCC,EAkCc,IAAMA,EAAQjB,KAGpCqB,MAAO,CAAC5C,EAAGC,WACHuC,EAAQvC,EAAIgC,EAAIjC,EACtB0C,EAAOF,IAvCD,IAuCkB,IAAMA,EAAQjB,MAGxCsB,SAAU,CAAC7C,EAAGC,EAAG6C,EAAIC,SACPC,EAAOC,EAAKC,EAAYC,EAAhCC,EAAIL,OACDK,GAAKnD,IAAKmD,KACfJ,EAAQI,EAAInB,EAAIjC,EAChBiD,EAAMG,EAAInB,EAAIa,EACdI,EAAaF,IA/CT,EAgDJG,EAAWF,IAhDP,EAiDAC,IAAeC,MACbb,EAAMY,GAAc1B,EAAOwB,EAAQzB,GAAOG,EAAqB,GAAbuB,EAAM1B,WACnD,MAEJ,IACDe,EAAMY,GAAc1B,EAAOwB,EAAQzB,GAAM,OAAO,KAChDe,EAAMa,GAAYzB,EAAqB,GAAbuB,EAAM1B,IAAW,OAAO,MACjD,IAAII,EAAIuB,EAAa,EAAGvB,EAAIwB,IAAYxB,KACvCW,EAAMX,GAAI,OAAO,SAIpB,GAGT0B,SAAU,CAACrD,EAAGC,EAAG6C,EAAIC,SACfC,EAAOC,EAAKC,EAAYC,EAAUxB,OAC/B1B,GAAK8C,IAAM9C,KAChB+C,EAAQ/C,EAAIgC,EAAIjC,EAChBiD,EAAMhD,EAAIgC,EAAIa,EACdI,EAAaF,IArET,EAsEJG,EAAWF,IAtEP,EAuEAC,IAAeC,EACjBZ,EAAKW,EAAY1B,EAAOwB,EAAQzB,GAAOG,EAAqB,GAAbuB,EAAM1B,cAErDgB,EAAKW,EAAY1B,EAAOwB,EAAQzB,IAChCgB,EAAKY,EAAUzB,EAAqB,GAAbuB,EAAM1B,KACxBI,EAAIuB,EAAa,EAAGvB,EAAIwB,IAAYxB,EAAGY,EAAKZ,EAAG,aAK1D2B,WAAY,CAACtD,EAAGC,EAAG6C,EAAIC,SACjBC,EAAOC,EAAKC,EAAYC,EAAUxB,OAC/B1B,GAAK8C,IAAM9C,KAChB+C,EAAQ/C,EAAIgC,EAAIjC,EAChBiD,EAAMhD,EAAIgC,EAAIa,EACdI,EAAaF,IAtFT,EAuFJG,EAAWF,IAvFP,EAwFAC,IAAeC,EACjBT,EAAOQ,EAAYxB,EAAOsB,EAAQzB,GAAOC,EAAqB,GAAbyB,EAAM1B,cAEvDmB,EAAOQ,EAAYxB,EAAOsB,EAAQzB,IAClCmB,EAAOS,EAAU3B,EAAqB,GAAbyB,EAAM1B,KAC1BI,EAAIuB,EAAa,EAAGvB,EAAIwB,IAAYxB,EAAGe,EAAOf,EAAG,IAK5D4B,YAAa,CAACvD,EAAGC,EAAG6C,EAAIC,IAAO/C,EAAI,GAAKC,EAAI,GAAK8C,GAAMb,GAAKY,GAAMb,GCzF/CuB,CAAOvB,EAAGC,GAC/BC,EAAMN,MAAQA,EACdM,EAAMP,QAAUA,EAChBO,EAAMnD,MAAQA,EACdmD,EAAMlD,OAASA,EAERkD,ECfT,SAASoB,EAAYvD,EAAGC,EAAGwD,EAAWC,EAAY1E,EAAOC,OACnDmE,EAAIK,EAAY,SACbzD,EAAIoD,EAAI,GACRpD,EAAIoD,EAAIpE,GACRiB,GAAKmD,EAAIM,EAAa,GAAK,GAC3BzD,EAAImD,EAAInE,EAGjB,SAAS0E,WACA,EAGT,SAASC,EAAUhF,EAAGoB,EAAGC,EAAGyD,EAAYD,EAAWvB,EAAG2B,EAAKC,SACnD7B,EAAKwB,EAAYvB,GAAmB,EAAbwB,GACvBK,EAAKnF,EAAEoB,EAAIiC,GACXa,EAAKlE,EAAEoB,EAAIiC,GACX+B,EAAKpF,EAAEqB,GAAKiC,GAAM,IAClBa,EAAKnE,EAAEqB,EAAIiC,UAEV2B,EAAIN,YAAYQ,EAAIC,EAAIlB,EAAIC,IAC5Bc,EAAIhB,SAASkB,EAAIC,EAAIlB,EAAIC,IACxBe,GAAOA,EAAIjB,SAASkB,EAAIC,EAAIlB,EAAIC,GAG1C,SAASkB,EAAWrF,EAAGoB,EAAGC,EAAGyD,EAAYD,EAAWvB,EAAG2B,EAAKC,SACpD7B,EAAKwB,EAAYvB,GAAmB,EAAbwB,OACzBK,EAAKnF,EAAEoB,EAAIiC,GACXa,EAAKlE,EAAEoB,EAAIiC,GACX+B,EAAKpF,EAAEqB,GAAKiC,GAAM,IAClBa,EAAKnE,EAAEqB,EAAIiC,UAEf6B,EAAKA,EAAK,EAAIA,EAAK,EACnBC,EAAKA,EAAK,EAAIA,EAAK,EACnBlB,EAAKA,EAAKlE,EAAEI,MAAQ8D,EAAKlE,EAAEI,MAAQ,EACnC+D,EAAKA,EAAKnE,EAAEK,OAAS8D,EAAKnE,EAAEK,OAAS,EAE9B4E,EAAIhB,SAASkB,EAAIC,EAAIlB,EAAIC,IAAQe,GAAOA,EAAIjB,SAASkB,EAAIC,EAAIlB,EAAIC,GAGnE,SAASmB,EAASC,UAChBA,EACH,CAACF,EAAYN,GACb,CAACC,EAAWL,GCtClB,MAAMa,EAAQ,EAAE,GAAI,EAAG,EAAG,GACpBC,EAAQ,EAAE,EAAG,GAAI,EAAG,GCH1B,MAAMC,EAAS,CAAC,QAAS,SAAU,QAC7BC,EAAY,CAAC,SAAU,SAAU,OAwFvC,SAASC,EAAKC,EAAKC,EAAKC,EAAKC,EAAKf,EAAKC,EAAKC,EAAIjB,EAAIkB,EAAIjB,EAAI8B,EAAUC,WAElEjB,EAAIN,YAAYkB,EAAKE,EAAKD,EAAKE,KAC9BE,GAAYhB,EACTA,EAAIjB,SAAS4B,EAAKE,EAAKD,EAAKE,KAKpC,SAAuBb,EAAIC,EAAIlB,EAAIC,EAAI8B,UAC9BA,EAAS,IAAMd,GAAMjB,GAAM+B,EAAS,IACpCA,EAAS,IAAMb,GAAMjB,GAAM8B,EAAS,GAPAE,CAAchB,EAAIC,EAAIlB,EAAIC,EAAI8B,GACnEhB,EAAIhB,SAAS4B,EAAKE,EAAKD,EAAKE,KCxFpC,MAQMI,EAAa,YACDC,MACAA,cACAA,OACAC,SACAA,QACAA,gBACAC,SACAA,iBACAA,IAGZC,EAAiB,OC1BR,SAASxG,EAAGyG,EAASC,EAAeC,SAC3CvG,EAAQJ,EAAEI,MACZC,EAASL,EAAEK,cAGR,SAASuG,SACRjG,EAAQiG,EAAEC,MAAMA,MAAMlG,MAAMgG,GAAWhG,MACvCmG,EAAInG,EAAMgB,OACVmD,EAAa8B,EAAEC,MAAME,SACrBlC,EAAYmC,cAAY5G,MAAMwG,EAAEC,MAAOD,EAAEC,MAAMI,UAGjD9B,EAAIjB,EAAIkB,EAAIjB,EAAI/C,EAAGC,EAAG6F,EADtBC,EAAe,MAId,IAAIpE,EAAE,EAAGA,EAAE+D,IAAK/D,EACnBoC,EAAKxE,EAAMoC,GAAG3B,EACdgE,EAAKzE,EAAMoC,GAAG1B,EACd6C,OAAqBkD,IAAhBzG,EAAMoC,GAAGmB,GAAmBiB,EAAKxE,EAAMoC,GAAGmB,GAC/CC,OAAqBiD,IAAhBzG,EAAMoC,GAAGoB,GAAmBiB,EAAKzE,EAAMoC,GAAGoB,GAC/C/C,GAAK+D,EAAKjB,GAAM,EAChB7C,GAAK+D,EAAKjB,GAAM,EAEhB+C,EAAYhE,KAAKmE,IAAInD,EAAKiB,EAAKhB,EAAKiB,GAChC8B,GAAaC,IACfA,EAAeD,EACfN,EAAExF,EAAIA,EACNwF,EAAEvF,EAAIA,UAIVD,EAAIyD,EAAY,EAChBxD,EAAIyD,EAAa,EACjBK,EAAKyB,EAAExF,EAAIA,EACX8C,EAAK0C,EAAExF,EAAIA,EACXgE,EAAKwB,EAAEvF,EAAIA,EACX8C,EAAKyC,EAAEvF,EAAIA,EAEXuF,EAAEU,MAAQ,SACNnC,EAAK,GAAKjB,GAAM9D,EAClBwG,EAAEU,MAAQ,OACD,GAAKnC,GAAM/E,EAAQ8D,IAC5B0C,EAAEU,MAAQ,SAGZV,EAAEW,SAAW,SACTnC,EAAK,GAAKjB,GAAM9D,EAClBuG,EAAEW,SAAW,MACJ,GAAKnC,GAAM/E,EAAS8D,IAC7ByC,EAAEW,SAAW,WAGR,qBCnDI,SAASvH,EAAGyG,EAASC,EAAeC,EAAWpB,SACtDnF,EAAQJ,EAAEI,MACZC,EAASL,EAAEK,QACV2E,EAAWL,GAAeW,EAASC,GACpCN,EAAMwB,EAAQ,GACdvB,EAAMuB,EAAQ,YAETe,EAASC,EAAIC,EAAIC,EAAS9C,EAAWC,SACtC1D,EAAIpB,EAAEyD,OAAOgE,GACbpG,EAAIrB,EAAEyD,OAAOiE,OAGfE,EAFAC,EAAKF,EACLG,EAAKzH,MAGNsE,EAAYvD,EAAGC,EAAGwD,EAAWC,EAAY1E,EAAOC,KAChD2E,EAAUhF,EAAGoB,EAAGC,EAAGyD,EAAYD,EAAWgD,EAAI5C,EAAKC,KACnDF,EAAUhF,EAAGoB,EAAGC,EAAGyD,EAAYD,EAAWC,EAAYG,EAAK,MAC5D,MAGO6C,EAAKD,GAAM,GAChBD,GAAOC,EAAKC,GAAM,EACd9C,EAAUhF,EAAGoB,EAAGC,EAAGyD,EAAYD,EAAW+C,EAAK3C,EAAKC,GACtD4C,EAAKF,EAELC,EAAKD,KAILC,EAAKF,QACA,CAACvG,EAAGC,EAAGwG,GAAI,WAMjB,SAASjB,SACRjG,EAAQiG,EAAEC,MAAMA,MAAMlG,MAAMgG,GAAWhG,MACvCmG,EAAInG,EAAMgB,OACVmD,EAAa8B,EAAEC,MAAME,SACrBlC,EAAYmC,cAAY5G,MAAMwG,EAAEC,MAAOD,EAAEC,MAAMI,UAMjD9B,EAAIjB,EAAIkB,EAAIjB,EAAI/C,EAAGC,EAAGoG,EAAIC,EAAI7B,EAAKkC,EAAOjC,EAAKC,EAAKiC,EAAOhC,EAAKkB,EAAWe,EAAQC,EAJnFP,EAAUjB,EAAgB5B,EAAa,EACvCqD,GAAc,EACdC,GAAe,EACfjB,EAAe,MAId,IAAIpE,EAAE,EAAGA,EAAE+D,IAAK/D,EAAG,KACtBoC,EAAKxE,EAAMoC,GAAG3B,EACdgE,EAAKzE,EAAMoC,GAAG1B,EACd6C,OAAqBkD,IAAhBzG,EAAMoC,GAAGmB,GAAmBiB,EAAKxE,EAAMoC,GAAGmB,GAC/CC,OAAqBiD,IAAhBzG,EAAMoC,GAAGoB,GAAmBiB,EAAKzE,EAAMoC,GAAGoB,GAE3CgB,EAAKjB,IACPgE,EAAU/C,EACVA,EAAKjB,EACLA,EAAKgE,GAGH9C,EAAKjB,IACP+D,EAAU9C,EACVA,EAAKjB,EACLA,EAAK+D,GAGPrC,EAAM7F,EAAEmF,GACRW,EAAM9F,EAAEkE,GACR6D,MAAYlC,EAAMC,GAAO,GACzBC,EAAM/F,EAAEoF,GACRY,EAAMhG,EAAEmE,GACR6D,MAAYjC,EAAMC,GAAO,GAGpByB,EAAKM,EAAON,GAAM5B,IAAO4B,MACvBC,EAAKM,EAAON,GAAM3B,IAAO2B,EAC5BO,EAAST,EAASC,EAAIC,EAAIC,EAAS9C,EAAWC,GAC1CmD,KACDrB,EAAExF,EAAGwF,EAAEvF,EAAGsG,EAASQ,GAAeF,OAMpCR,EAAKM,EAAON,GAAM3B,IAAO2B,MACvBC,EAAKM,EAAON,GAAM1B,IAAO0B,EAC5BO,EAAST,EAASC,EAAIC,EAAIC,EAAS9C,EAAWC,GAC1CmD,KACDrB,EAAExF,EAAGwF,EAAEvF,EAAGsG,EAASQ,GAAeF,GAOpCE,GAAgBzB,IAEnBQ,EAAYhE,KAAKmE,IAAInD,EAAKiB,EAAKhB,EAAKiB,GACpChE,GAAK+D,EAAKjB,GAAM,EAChB7C,GAAK+D,EAAKjB,GAAM,EAId+C,GAAaC,IACZxC,EAAYvD,EAAGC,EAAGwD,EAAWC,EAAY1E,EAAOC,KAChD2E,EAAUhF,EAAGoB,EAAGC,EAAGyD,EAAYD,EAAWC,EAAYG,EAAK,QAE5DkC,EAAeD,EACfN,EAAExF,EAAIA,EACNwF,EAAEvF,EAAIA,EACN+G,GAAe,aAMjBD,IAAeC,KACjBhH,EAAIyD,EAAY,EAChBxD,EAAIyD,EAAa,EACjBG,EAAIR,SAASzE,EAAE4G,EAAExF,EAAIA,GAAIpB,EAAE4G,EAAEvF,EAAIA,GAAIrB,EAAE4G,EAAExF,EAAIA,GAAIpB,EAAE4G,EAAEvF,EAAIA,IACzDuF,EAAEU,MAAQ,SACVV,EAAEW,SAAW,UACN,eJvHE,SAASvH,EAAGyG,EAASC,EAAeC,EAAWpB,SACtDnF,EAAQJ,EAAEI,MACZC,EAASL,EAAEK,QACV2E,EAAWL,GAAeW,EAASC,GACpCN,EAAMwB,EAAQ,GACdvB,EAAMuB,EAAQ,GACd4B,EAAMrI,EAAEkB,gBAGL,SAAS0F,SACRjG,EAAQiG,EAAEC,MAAMA,MAAMlG,MAAMgG,GAAWhG,MACvCmG,EAAInG,EAAMgB,OACVmD,EAAa8B,EAAEC,MAAME,SACrBlC,EAAYmC,cAAY5G,MAAMwG,EAAEC,MAAOD,EAAEC,MAAMI,MAC/CqB,EAAQ,OAMVnD,EAAIjB,EAAIkB,EAAIjB,EAAI/C,EAAGC,EAAGoG,EAAIC,EAAIG,EAAIC,EAAIF,EAAKV,EAJ3CS,EAAUjB,EAAgB5B,EAAa,EACvCqD,GAAc,EACdC,GAAe,EACfjB,EAAe,MAId,IAAIpE,EAAE,EAAGA,EAAE+D,IAAK/D,EAAG,KACtBoC,EAAKxE,EAAMoC,GAAG3B,EACdgE,EAAKzE,EAAMoC,GAAG1B,EACd6C,OAAqBkD,IAAhBzG,EAAMoC,GAAGmB,GAAmBiB,EAAKxE,EAAMoC,GAAGmB,GAC/CC,OAAqBiD,IAAhBzG,EAAMoC,GAAGoB,GAAmBiB,EAAKzE,EAAMoC,GAAGoB,GAG/CmE,EAAMC,KAAK,CAACvI,GAAGmF,EAAKjB,GAAM,GAAIlE,GAAGoF,EAAKjB,GAAM,KAGrCmE,EAAM3G,YACV8F,EAAIC,GAAMY,EAAME,QAGbvD,EAAIlB,IAAI0D,EAAIC,IAAOxC,EAAInB,IAAI0D,EAAIC,IAAOW,EAAItE,IAAI0D,EAAIC,KAItDW,EAAI5G,IAAIgG,EAAIC,OACP,IAAIe,EAAE,EAAGA,EAAE,IAAKA,EACnBrH,EAAIqG,EAAKjC,EAAMiD,GACfpH,EAAIqG,EAAKjC,EAAMgD,GACVJ,EAAI1D,YAAYvD,EAAGC,EAAGD,EAAGC,IAAIiH,EAAMC,KAAK,CAACnH,EAAGC,OAInDD,EAAIpB,EAAEyD,OAAOgE,GACbpG,EAAIrB,EAAEyD,OAAOiE,GACbG,EAAKF,EACLG,EAAKzH,GAGFsE,EAAYvD,EAAGC,EAAGwD,EAAWC,EAAY1E,EAAOC,KAChD2E,EAAUhF,EAAGoB,EAAGC,EAAGyD,EAAYD,EAAWgD,EAAI5C,EAAKC,KACnDF,EAAUhF,EAAGoB,EAAGC,EAAGyD,EAAYD,EAAWC,EAAYG,EAAK,MAC5D,MAGO6C,EAAKD,GAAM,GAChBD,GAAOC,EAAKC,GAAM,EACd9C,EAAUhF,EAAGoB,EAAGC,EAAGyD,EAAYD,EAAW+C,EAAK3C,EAAKC,GACtD4C,EAAKF,EAELC,EAAKD,EAILC,EAAKF,IACPf,EAAExF,EAAIA,EACNwF,EAAEvF,EAAIA,EACNsG,EAAUE,EACVM,GAAc,IAOfA,GAAgBzB,IAEnBQ,EAAYhE,KAAKmE,IAAInD,EAAKiB,EAAKhB,EAAKiB,GACpChE,GAAK+D,EAAKjB,GAAM,EAChB7C,GAAK+D,EAAKjB,GAAM,EAId+C,GAAaC,IACZxC,EAAYvD,EAAGC,EAAGwD,EAAWC,EAAY1E,EAAOC,KAChD2E,EAAUhF,EAAGoB,EAAGC,EAAGyD,EAAYD,EAAWC,EAAYG,EAAK,QAE5DkC,EAAeD,EACfN,EAAExF,EAAIA,EACNwF,EAAEvF,EAAIA,EACN+G,GAAe,aAMjBD,IAAeC,KACjBhH,EAAIyD,EAAY,EAChBxD,EAAIyD,EAAa,EACjBG,EAAIR,SAASzE,EAAE4G,EAAExF,EAAIA,GAAIpB,EAAE4G,EAAEvF,EAAIA,GAAIrB,EAAE4G,EAAExF,EAAIA,GAAIpB,EAAE4G,EAAEvF,EAAIA,IACzDuF,EAAEU,MAAQ,SACVV,EAAEW,SAAW,UACN,MEjFE,WAASmB,EAAOC,EAAMC,EAASC,EAAQC,EACpD7I,EAAYyG,EAAeqC,EAAYpC,EAAW3D,EAASgG,OAGtDN,EAAM/G,OAAQ,OAAO+G,QAEpBO,EAAY/F,KAAKC,IAAI0F,EAAOlH,OAAQmH,EAAOnH,QAC3CuH,EA2DR,SAAoB1F,EAAG2F,SACfD,EAAU,IAAIE,aAAaD,GAC3BrC,EAAItD,EAAE7B,WACP,IAAIoB,EAAE,EAAGA,EAAE+D,IAAK/D,EAAGmG,EAAQnG,GAAKS,EAAET,IAAM,MACxC,IAAIA,EAAE+D,EAAG/D,EAAEoG,IAASpG,EAAGmG,EAAQnG,GAAKmG,EAAQpC,EAAI,UAC9CoC,EAhESG,CAAWR,EAAQI,GAC7BK,EAkER,SAAoB9F,EAAG2F,SACfG,EAAU,IAAIC,UAAUJ,GACxBrC,EAAItD,EAAE7B,WACP,IAAIoB,EAAE,EAAGA,EAAE+D,IAAK/D,EAAGuG,EAAQvG,IAAMqD,EAAW5C,EAAET,QAC9C,IAAIA,EAAE+D,EAAG/D,EAAEoG,IAASpG,EAAGuG,EAAQvG,GAAKuG,EAAQxC,EAAI,UAC9CwC,EAvESE,CAAWV,EAAQG,GAC7BnH,GAyEUM,EAzEUsG,EAAM,GAAG7B,QA0EpBzE,EAAKP,MAAQO,EAAKP,KAAKC,SAzEhC2H,EAAyB,UAAb3H,GAAwB4G,EAAM,GAAG7B,MAAMlG,MAAMgG,GAAW7E,SACpE3B,EAA4B,SAAdsJ,EACdxD,EAiFR,SAAsBnE,EAAU2H,EAAWV,EAAYpC,SAC/C+C,EAAK9C,GAAK,CAACA,EAAExF,EAAGwF,EAAExF,EAAGwF,EAAExF,EAAGwF,EAAEvF,EAAGuF,EAAEvF,EAAGuF,EAAEvF,UAEvCS,EAIiB,SAAbA,GAAoC,SAAbA,EACvB8E,GAAK8C,EAAG9C,EAAEC,OAGI,SAAd4C,EACA7C,UACCjG,EAAQiG,EAAEC,MAAMlG,MAAMgG,GAAWhG,aAChC+I,EAAG/I,EAAMgB,OACZhB,EAAqB,UAAfoI,EAAyB,EAAIpI,EAAMgB,OAAS,GAClD,CAACP,EAAGuI,IAAKtI,EAAGsI,OAKX/C,UACCgD,EAAIhD,EAAEC,MAAMgD,aACX,CAACD,EAAEzE,IAAKyE,EAAEzE,GAAKyE,EAAE1F,IAAM,EAAG0F,EAAE1F,GAAI0F,EAAExE,IAAKwE,EAAExE,GAAKwE,EAAEzF,IAAM,EAAGyF,EAAEzF,KAnB7DuF,EArFQI,CAAahI,EAAU2H,EAAWV,EAAYpC,GACzDpB,EAAyB,OAAZvC,GAAoBA,IAAY+G,EAAAA,EAC7C/J,EAAIgK,EAAOrB,EAAK,GAAIA,EAAK,GAAIpD,EAAa,EAAIvC,GAC9CiH,EAAmB9J,GAA0B,UAAX6I,EAmE1C,IAAkB5G,QAhEVpB,EAAO0H,EAAMzG,KAAI2E,KACrBC,MAAOD,EACPsD,QAAS,EACT9I,OAAGgG,EACH/F,OAAG+F,EACHE,WAAOF,EACPG,cAAUH,EACVnB,SAAUA,EAASW,WAGjBH,MACCwD,EAAkB,CAEjBrB,GACF5H,EAAKmJ,MAAK,CAACC,EAAGR,IAAMhB,EAAQwB,EAAEvD,MAAO+C,EAAE/C,aAIrC3G,GAAc,MACb,IAAI6C,EAAE,EAAGA,EAAIuG,EAAQ3H,SAAWzB,IAAe6C,EAGlD7C,EAA6B,IAAfoJ,EAAQvG,IAAcmG,EAAQnG,GAAK,EAK/CjB,IAAa4E,GAAiBvG,KAChCF,EAAa,CAACyI,EAAMzG,KAAI2E,GAAKA,EAAEC,SAAQwD,OAAOpK,IAIhDwG,EAAUxG,EAAW0B,OACjB5B,EAAYC,EAAGC,EAAYC,EAAaC,GN1EzC,SAAqBH,EAAGgB,SACvBE,EAASlB,EAAEkB,gBAEhBF,GAAQ,IAAIN,SAAQkG,GAAK1F,EAAOO,IAAIzB,EAAE4G,EAAEX,SAAS,IAAKjG,EAAE4G,EAAEX,SAAS,OAC7D,CAAC/E,OAAQkG,GMuEVkD,CAAYtK,EAAG0G,GAAiB1F,SAIhCuJ,EAAQpK,EACVqG,EAAewC,GAAQhJ,EAAGyG,EAASC,EAAeC,EAAWpB,GDtFpD,SAASvF,EAAGyG,EAAS6C,EAASJ,EAAS3D,SAC9CnF,EAAQJ,EAAEI,MACVC,EAASL,EAAEK,OACX4E,EAAMwB,EAAQ,GACdvB,EAAMuB,EAAQ,GACdK,EAAIoC,EAAQvH,cAEX,SAASiF,SACRX,EAAWW,EAAEX,SACbnB,EAAa8B,EAAEC,MAAME,aAGtBxB,IAAeU,EAAS,GAAK,GAAKA,EAAS,GAAK,GAAKA,EAAS,GAAK7F,GAAS6F,EAAS,GAAK5F,UACtF,MAILmK,EAAIC,EAAIvE,EAAUwE,EAAYC,EAC9BxF,EAAIjB,EAAIkB,EAAIjB,EAAIyG,EAAIC,EACpBhF,EAAKC,EAAKC,EAAKC,EAHfnB,EAAY,MAMX,IAAI9B,EAAE,EAAGA,EAAE+D,IAAK/D,EAAG,IACtByH,GAAmB,EAAblB,EAAQvG,IAAY,EAC1B0H,GAAOnB,EAAQvG,KAAO,EAAO,GAAO,EAEpCmD,EAAmB,IAAPsE,GAAmB,IAAPC,GAAavB,EAAQnG,GAAK,EAClD2H,EAAaF,GAAMC,EAAKvH,KAAK4H,QAAU,EACvCH,EAAezB,EAAQnG,GAAK,GAAK,EAAI,EAErCoC,EAAKc,EAAS,EAAIuE,GAAMtB,EAAQnG,GAAKyH,EAAKE,EAC1CG,EAAK5E,EAAS,EAAIwE,GAAOE,EAAe7F,EAAa2F,EAAM,EAAIvB,EAAQnG,GAAK0H,EAAKC,EACjFtF,EAAKyF,EAAK/F,EAAa,EACvBX,EAAK0G,EAAK/F,EAAa,EAEvBe,EAAM7F,EAAEmF,GACRY,EAAM/F,EAAEoF,GACRY,EAAMhG,EAAEmE,GAEJoB,IACFM,EAAMA,EAAM,EAAI,EAAIA,EACpBE,EAAMA,EAAM,EAAI,EAAIA,EACpBC,EAAMA,GAAOhG,EAAEK,OAAUL,EAAEK,OAAS,EAAK2F,IAGtCnB,EAAW,KAETe,EAAKC,EAAKA,EAAKE,EAAKC,EAAKf,EAAKC,EAAKC,EAAIA,EAAIC,EAAIjB,EAAI8B,EAAUC,YAKhErB,EAAYmC,cAAY5G,MAAMwG,EAAEC,MAAOD,EAAEC,MAAMI,SAInD2D,EAAKzF,EAAMwF,EAAe9F,EAAY2F,EAAM,EAC5CrF,EAAKyF,EAAK/F,EAAY,EACtBX,EAAK0G,EAAK/F,EAAY,EAEtBgB,EAAM7F,EAAEmF,GACRW,EAAM9F,EAAEkE,GAEJqB,IACFM,EAAMA,EAAM,EAAI,EAAIA,EACpBC,EAAMA,GAAO9F,EAAEI,MAASJ,EAAEI,MAAQ,EAAK0F,GAGrCF,EAAKC,EAAKC,EAAKC,EAAKC,EAAKf,EAAKC,EAAKC,EAAIjB,EAAIkB,EAAIjB,EAAI8B,EAAUC,UAE/DU,EAAExF,EAAKoJ,EAAUA,EAAKG,EAAe,EAAIzG,EAAKiB,EAAlCyF,EACZhE,EAAEvF,EAAKoJ,EAAUA,EAAKE,EAAe,EAAIxG,EAAKiB,EAAlCyF,EAEZjE,EAAEU,MAAQ5B,EAAO8E,EAAKG,EAAe,GACrC/D,EAAEW,SAAW5B,EAAU8E,EAAKE,EAAe,GAE3C1F,EAAIR,SAASoB,EAAKE,EAAKD,EAAKE,IACrB,SAIJ,GCML+E,CAAe/K,EAAGyG,EAAS6C,EAASJ,EAAS3D,UAGjDvE,EAAKN,SAAQkG,GAAKA,EAAEsD,SAAWK,EAAM3D,KAE9B5F,EG7FT,MAAMgK,EAAS,CACb,IACA,IACA,UACA,QACA,YAGIC,EAAU,CACd,WACA,OACA,cACA,MACA,SACA,YACA,QACA,gBA8Ba,SAASC,EAAMC,GAC5BC,YAAUC,KAAKC,KAAM,KAAMH,GAG7BD,EAAMK,WAAa,CACjB3J,KAAM,QACN4J,SAAU,CAAEC,UAAU,GACtBN,OAAQ,CACN,CAAEO,KAAM,OAAQ9J,KAAM,SAAU8B,OAAO,EAAM/B,OAAQ,EAAGgK,UAAU,GAClE,CAAED,KAAM,OAAQ9J,KAAM,WACtB,CAAE8J,KAAM,SAAU9J,KAAM,SAAU8B,OAAO,EAAMkI,QAASX,GACxD,CAAES,KAAM,SAAU9J,KAAM,SAAU8B,OAAO,EAAMkI,QAAS,CAAC,IACzD,CAAEF,KAAM,UAAW9J,KAAM,SAAUgK,QAAS,EAAGC,MAAM,GACrD,CAAEH,KAAM,aAAc9J,KAAM,SAAUkK,OAAQ,CAAC,QAAS,OAAQF,QAAS,OACzE,CAAEF,KAAM,YAAa9J,KAAM,SAAUgK,QAAS,GAC9C,CAAEF,KAAM,gBAAiB9J,KAAM,UAAWgK,SAAS,GACnD,CAAEF,KAAM,aAAc9J,KAAM,OAAQ8B,OAAO,GAC3C,CAAEgI,KAAM,SAAU9J,KAAM,SAAUgK,QAAS,SAC3C,CAAEF,KAAM,KAAM9J,KAAM,SAAU8B,OAAO,EAAM/B,OAAQqJ,EAAOrJ,OAAQiK,QAASZ,gBAItEE,EAAOE,YAAW,CACzBW,UAAUvI,EAAGwI,SAMLC,EAAMzI,EAAE0I,gBACRD,GAAOD,EAAMG,QAAQH,EAAMI,mBANnBC,SACNC,EAAI9I,EAAE6I,UACLE,aAAWD,IAAMN,EAAME,SAASI,EAAEE,QAIEC,CAAK,SAAU,OACvDjJ,EAAEmF,MAA0B,IAAlBnF,EAAEmF,KAAKhH,QACpB+K,QAAM,wEAGFC,EAAKnJ,EAAEmJ,IAAM3B,SAGnB4B,EACEZ,EAAMa,YAAYb,EAAMc,QAAQ3K,QAAU,GAC1CqB,EAAEmF,KACFnF,EAAE2G,KACFzG,QAAkB,MAAZF,EAAEqF,OAAiB,EAAIrF,EAAEqF,QAC/BnF,QAAMF,EAAEsF,QAAUmC,GAClBzH,EAAEvD,YAAc,IACI,IAApBuD,EAAEkD,cACFlD,EAAEuF,YAAc,MAChBvF,EAAEmD,WAAa,OACDS,IAAd5D,EAAER,QAAwB,EAAIQ,EAAER,QAChCQ,EAAEwF,QAAU,SACZtI,SAAQqM,UAEFC,EAAID,EAAElG,MACZmG,EAAEL,EAAG,IAAMI,EAAE3L,EACb4L,EAAEL,EAAG,IAAMI,EAAE1L,EACb2L,EAAEL,EAAG,IAAMI,EAAE7C,QACb8C,EAAEL,EAAG,IAAMI,EAAEzF,MACb0F,EAAEL,EAAG,IAAMI,EAAExF,YAGRyE,EAAMiB,OAAOhB,GAAKR,SAASkB"}