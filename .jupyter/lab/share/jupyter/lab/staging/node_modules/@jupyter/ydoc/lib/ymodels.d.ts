import type * as nbformat from '@jupyterlab/nbformat';
import { JSONObject, JSONValue, PartialJSONValue } from '@lumino/coreutils';
import { ISignal, Signal } from '@lumino/signaling';
import { Awareness } from 'y-protocols/awareness';
import * as Y from 'yjs';
import type { CellChange, DocumentChange, FileChange, IMapChange, ISharedAttachmentsCell, ISharedBaseCell, ISharedCodeCell, ISharedDocument, ISharedFile, ISharedMarkdownCell, ISharedNotebook, ISharedRawCell, ISharedText, NotebookChange, SharedCell } from './api.js';
/**
 * Abstract interface to define Shared Models that can be bound to a text editor using any existing
 * Yjs-based editor binding.
 */
export interface IYText extends ISharedText {
    /**
     * Shareable text
     */
    readonly ysource: Y.Text;
    /**
     * Shareable awareness
     */
    readonly awareness: Awareness | null;
    /**
     * Undo manager
     */
    readonly undoManager: Y.UndoManager | null;
}
/**
 * Generic shareable document.
 */
export declare class YDocument<T extends DocumentChange> implements ISharedDocument {
    constructor();
    /**
     * YJS document
     */
    readonly ydoc: Y.Doc;
    /**
     * Shared state
     */
    readonly ystate: Y.Map<any>;
    /**
     * YJS document undo manager
     */
    readonly undoManager: Y.UndoManager;
    /**
     * Shared awareness
     */
    readonly awareness: Awareness;
    /**
     * The changed signal.
     */
    get changed(): ISignal<this, T>;
    /**
     * Whether the document is disposed or not.
     */
    get isDisposed(): boolean;
    /**
     * Document state
     */
    get state(): JSONObject;
    /**
     * Whether the object can undo changes.
     */
    canUndo(): boolean;
    /**
     * Whether the object can redo changes.
     */
    canRedo(): boolean;
    /**
     * Dispose of the resources.
     */
    dispose(): void;
    /**
     * Get the value for a state attribute
     *
     * @param key Key to get
     */
    getState(key: string): JSONValue | undefined;
    /**
     * Set the value of a state attribute
     *
     * @param key Key to set
     * @param value New attribute value
     */
    setState(key: string, value: JSONValue): void;
    /**
     * Undo an operation.
     */
    undo(): void;
    /**
     * Redo an operation.
     */
    redo(): void;
    /**
     * Clear the change stack.
     */
    clearUndoHistory(): void;
    /**
     * Perform a transaction. While the function f is called, all changes to the shared
     * document are bundled into a single event.
     */
    transact(f: () => void, undoable?: boolean): void;
    /**
     * Handle a change to the ystate.
     */
    protected onStateChanged: (event: Y.YMapEvent<any>) => void;
    protected _changed: Signal<this, T>;
    private _isDisposed;
}
/**
 * Shareable text file.
 */
export declare class YFile extends YDocument<FileChange> implements ISharedFile, ISharedText, IYText {
    /**
     * Create a new file
     *
     * #### Notes
     * The document is empty and must be populated
     */
    constructor();
    /**
     * YJS file text.
     */
    readonly ysource: Y.Text;
    /**
     * File text
     */
    get source(): string;
    set source(v: string);
    /**
     * Dispose of the resources.
     */
    dispose(): void;
    /**
     * Get the file text.
     *
     * @returns File text.
     */
    getSource(): string;
    /**
     * Set the file text.
     *
     * @param value New text
     */
    setSource(value: string): void;
    /**
     * Replace content from `start' to `end` with `value`.
     *
     * @param start: The start index of the range to replace (inclusive).
     * @param end: The end index of the range to replace (exclusive).
     * @param value: New source (optional).
     */
    updateSource(start: number, end: number, value?: string): void;
    /**
     * Handle a change to the ymodel.
     */
    private _modelObserver;
}
/**
 * Create a new cell that cannot be inserted in an existing shared model.
 *
 * @param cell Cell JSON representation
 */
export declare const createStandaloneCell: (cell: SharedCell.Cell) => YCellType;
export declare class YBaseCell<Metadata extends nbformat.IBaseCellMetadata> implements ISharedBaseCell<Metadata>, IYText {
    /**
     * Create a new YCell that works standalone. It cannot be
     * inserted into a YNotebook because the Yjs model is already
     * attached to an anonymous Y.Doc instance.
     */
    static createStandalone(id?: string): YBaseCell<any>;
    /**
     * Base cell constructor
     *
     * ### Notes
     * Don't use the constructor directly - prefer using ``YNotebook.insertCell``
     *
     * The ``ysource`` is needed because ``ymodel.get('source')`` will
     * not return the real source if the model is not yet attached to
     * a document. Requesting it explicitly allows to introspect a non-empty
     * source before the cell is attached to the document.
     *
     * @param ymodel Cell map
     * @param ysource Cell source
     * @param options { notebook?: The notebook the cell is attached to }
     */
    constructor(ymodel: Y.Map<any>, ysource: Y.Text, options?: SharedCell.IOptions);
    /**
     * Cell notebook awareness or null if the cell is standalone.
     */
    get awareness(): Awareness | null;
    /**
     * The type of the cell.
     */
    get cell_type(): any;
    /**
     * The changed signal.
     */
    get changed(): ISignal<this, CellChange<Metadata>>;
    /**
     * Signal emitted when the cell is disposed.
     */
    get disposed(): ISignal<this, void>;
    /**
     * Cell id
     */
    get id(): string;
    /**
     * Whether the model has been disposed or not.
     */
    get isDisposed(): boolean;
    /**
     * Whether the cell is standalone or not.
     *
     * If the cell is standalone. It cannot be
     * inserted into a YNotebook because the Yjs model is already
     * attached to an anonymous Y.Doc instance.
     */
    get isStandalone(): boolean;
    /**
     * Cell metadata.
     */
    get metadata(): Partial<Metadata>;
    set metadata(v: Partial<Metadata>);
    /**
     * Signal triggered when the cell metadata changes.
     */
    get metadataChanged(): ISignal<this, IMapChange>;
    /**
     * The notebook that this cell belongs to.
     */
    get notebook(): YNotebook | null;
    /**
     * Cell input content.
     */
    get source(): string;
    set source(v: string);
    /**
     * The cell undo manager.
     */
    get undoManager(): Y.UndoManager | null;
    /**
     * Defer setting the undo manager as it requires the
     * cell to be attached to the notebook Y document.
     */
    setUndoManager(): void;
    readonly ymodel: Y.Map<any>;
    get ysource(): Y.Text;
    /**
     * Whether the object can undo changes.
     */
    canUndo(): boolean;
    /**
     * Whether the object can redo changes.
     */
    canRedo(): boolean;
    /**
     * Clear the change stack.
     */
    clearUndoHistory(): void;
    /**
     * Undo an operation.
     */
    undo(): void;
    /**
     * Redo an operation.
     */
    redo(): void;
    /**
     * Dispose of the resources.
     */
    dispose(): void;
    /**
     * Get cell id.
     *
     * @returns Cell id
     */
    getId(): string;
    /**
     * Gets cell's source.
     *
     * @returns Cell's source.
     */
    getSource(): string;
    /**
     * Sets cell's source.
     *
     * @param value: New source.
     */
    setSource(value: string): void;
    /**
     * Replace content from `start' to `end` with `value`.
     *
     * @param start: The start index of the range to replace (inclusive).
     *
     * @param end: The end index of the range to replace (exclusive).
     *
     * @param value: New source (optional).
     */
    updateSource(start: number, end: number, value?: string): void;
    /**
     * Delete a metadata cell.
     *
     * @param key The key to delete
     */
    deleteMetadata(key: string): void;
    /**
     * Returns all or a single metadata associated with the cell.
     *
     * @param key The metadata key
     * @returns cell's metadata.
     */
    getMetadata(): Partial<Metadata>;
    getMetadata(key: string): PartialJSONValue | undefined;
    /**
     * Sets all or a single cell metadata.
     *
     * If only one argument is provided, it will override all cell metadata.
     * Otherwise a single key will be set to a new value.
     *
     * @param metadata Cell's metadata key or cell's metadata.
     * @param value Metadata value
     */
    setMetadata(metadata: Partial<Metadata>): void;
    setMetadata(metadata: string, value: PartialJSONValue): void;
    /**
     * Serialize the model to JSON.
     */
    toJSON(): nbformat.IBaseCell;
    /**
     * Perform a transaction. While the function f is called, all changes to the shared
     * document are bundled into a single event.
     */
    transact(f: () => void, undoable?: boolean): void;
    /**
     * Extract changes from YJS events
     *
     * @param events YJS events
     * @returns Cell changes
     */
    protected getChanges(events: Y.YEvent<any>[]): Partial<CellChange<Metadata>>;
    /**
     * Handle a change to the ymodel.
     */
    private _modelObserver;
    protected _metadataChanged: Signal<this, IMapChange<any>>;
    /**
     * The notebook that this cell belongs to.
     */
    protected _notebook: YNotebook | null;
    private _awareness;
    private _changed;
    private _disposed;
    private _isDisposed;
    private _prevSourceLength;
    private _undoManager;
    private _ysource;
}
/**
 * Shareable code cell.
 */
export declare class YCodeCell extends YBaseCell<nbformat.IBaseCellMetadata> implements ISharedCodeCell {
    /**
     * Create a new YCodeCell that works standalone. It cannot be
     * inserted into a YNotebook because the Yjs model is already
     * attached to an anonymous Y.Doc instance.
     */
    static createStandalone(id?: string): YCodeCell;
    /**
     * Code cell constructor
     *
     * ### Notes
     * Don't use the constructor directly - prefer using ``YNotebook.insertCell``
     *
     * The ``ysource`` is needed because ``ymodel.get('source')`` will
     * not return the real source if the model is not yet attached to
     * a document. Requesting it explicitly allows to introspect a non-empty
     * source before the cell is attached to the document.
     *
     * @param ymodel Cell map
     * @param ysource Cell source
     * @param youtputs Code cell outputs
     * @param options { notebook?: The notebook the cell is attached to }
     */
    constructor(ymodel: Y.Map<any>, ysource: Y.Text, youtputs: Y.Array<any>, options?: SharedCell.IOptions);
    /**
     * The type of the cell.
     */
    get cell_type(): 'code';
    /**
     * The code cell's prompt number. Will be null if the cell has not been run.
     */
    get execution_count(): number | null;
    set execution_count(count: number | null);
    /**
     * Cell outputs.
     */
    get outputs(): Array<nbformat.IOutput>;
    set outputs(v: Array<nbformat.IOutput>);
    /**
     * Execution, display, or stream outputs.
     */
    getOutputs(): Array<nbformat.IOutput>;
    /**
     * Replace all outputs.
     */
    setOutputs(outputs: Array<nbformat.IOutput>): void;
    /**
     * Replace content from `start' to `end` with `outputs`.
     *
     * @param start: The start index of the range to replace (inclusive).
     *
     * @param end: The end index of the range to replace (exclusive).
     *
     * @param outputs: New outputs (optional).
     */
    updateOutputs(start: number, end: number, outputs?: Array<nbformat.IOutput>): void;
    /**
     * Serialize the model to JSON.
     */
    toJSON(): nbformat.ICodeCell;
    /**
     * Extract changes from YJS events
     *
     * @param events YJS events
     * @returns Cell changes
     */
    protected getChanges(events: Y.YEvent<any>[]): Partial<CellChange<nbformat.IBaseCellMetadata>>;
    private _youtputs;
}
declare class YAttachmentCell extends YBaseCell<nbformat.IBaseCellMetadata> implements ISharedAttachmentsCell {
    /**
     * Cell attachments
     */
    get attachments(): nbformat.IAttachments | undefined;
    set attachments(v: nbformat.IAttachments | undefined);
    /**
     * Gets the cell attachments.
     *
     * @returns The cell attachments.
     */
    getAttachments(): nbformat.IAttachments | undefined;
    /**
     * Sets the cell attachments
     *
     * @param attachments: The cell attachments.
     */
    setAttachments(attachments: nbformat.IAttachments | undefined): void;
    /**
     * Extract changes from YJS events
     *
     * @param events YJS events
     * @returns Cell changes
     */
    protected getChanges(events: Y.YEvent<any>[]): Partial<CellChange<nbformat.IBaseCellMetadata>>;
}
/**
 * Shareable raw cell.
 */
export declare class YRawCell extends YAttachmentCell implements ISharedRawCell {
    /**
     * Create a new YRawCell that works standalone. It cannot be
     * inserted into a YNotebook because the Yjs model is already
     * attached to an anonymous Y.Doc instance.
     */
    static createStandalone(id?: string): YRawCell;
    /**
     * String identifying the type of cell.
     */
    get cell_type(): 'raw';
    /**
     * Serialize the model to JSON.
     */
    toJSON(): nbformat.IRawCell;
}
/**
 * Shareable markdown cell.
 */
export declare class YMarkdownCell extends YAttachmentCell implements ISharedMarkdownCell {
    /**
     * Create a new YMarkdownCell that works standalone. It cannot be
     * inserted into a YNotebook because the Yjs model is already
     * attached to an anonymous Y.Doc instance.
     */
    static createStandalone(id?: string): YMarkdownCell;
    /**
     * String identifying the type of cell.
     */
    get cell_type(): 'markdown';
    /**
     * Serialize the model to JSON.
     */
    toJSON(): nbformat.IMarkdownCell;
}
/**
 * Cell type.
 */
export type YCellType = YRawCell | YCodeCell | YMarkdownCell;
/**
 * Shared implementation of the Shared Document types.
 *
 * Shared cells can be inserted into a SharedNotebook.
 * Shared cells only start emitting events when they are connected to a SharedNotebook.
 *
 * "Standalone" cells must not be inserted into a (Shared)Notebook.
 * Standalone cells emit events immediately after they have been created, but they must not
 * be included into a (Shared)Notebook.
 */
export declare class YNotebook extends YDocument<NotebookChange> implements ISharedNotebook {
    /**
     * Create a new notebook
     *
     * #### Notes
     * The document is empty and must be populated
     *
     * @param options
     */
    constructor(options?: ISharedNotebook.IOptions);
    /**
     * YJS map for the notebook metadata
     */
    readonly ymeta: Y.Map<any>;
    /**
     * Cells list
     */
    readonly cells: YCellType[];
    /**
     * Wether the undo/redo logic should be
     * considered on the full document across all cells.
     *
     * Default: false
     */
    get disableDocumentWideUndoRedo(): boolean;
    /**
     * Notebook metadata
     */
    get metadata(): nbformat.INotebookMetadata;
    set metadata(v: nbformat.INotebookMetadata);
    /**
     * Signal triggered when a metadata changes.
     */
    get metadataChanged(): ISignal<this, IMapChange>;
    /**
     * nbformat major version
     */
    get nbformat(): number;
    set nbformat(value: number);
    /**
     * nbformat minor version
     */
    get nbformat_minor(): number;
    set nbformat_minor(value: number);
    /**
     * Dispose of the resources.
     */
    dispose(): void;
    /**
     * Get a shared cell by index.
     *
     * @param index: Cell's position.
     *
     * @returns The requested shared cell.
     */
    getCell(index: number): YCellType;
    /**
     * Add a shared cell at the notebook bottom.
     *
     * @param cell Cell to add.
     *
     * @returns The added cell.
     */
    addCell(cell: SharedCell.Cell): YBaseCell<nbformat.IBaseCellMetadata>;
    /**
     * Insert a shared cell into a specific position.
     *
     * @param index: Cell's position.
     * @param cell: Cell to insert.
     *
     * @returns The inserted cell.
     */
    insertCell(index: number, cell: SharedCell.Cell): YBaseCell<nbformat.IBaseCellMetadata>;
    /**
     * Insert a list of shared cells into a specific position.
     *
     * @param index: Position to insert the cells.
     * @param cells: Array of shared cells to insert.
     *
     * @returns The inserted cells.
     */
    insertCells(index: number, cells: SharedCell.Cell[]): YBaseCell<nbformat.IBaseCellMetadata>[];
    /**
     * Move a cell.
     *
     * @param fromIndex: Index of the cell to move.
     * @param toIndex: New position of the cell.
     */
    moveCell(fromIndex: number, toIndex: number): void;
    /**
     * Move cells.
     *
     * @param fromIndex: Index of the first cells to move.
     * @param toIndex: New position of the first cell (in the current array).
     * @param n: Number of cells to move (default 1)
     */
    moveCells(fromIndex: number, toIndex: number, n?: number): void;
    /**
     * Remove a cell.
     *
     * @param index: Index of the cell to remove.
     */
    deleteCell(index: number): void;
    /**
     * Remove a range of cells.
     *
     * @param from: The start index of the range to remove (inclusive).
     * @param to: The end index of the range to remove (exclusive).
     */
    deleteCellRange(from: number, to: number): void;
    /**
     * Delete a metadata notebook.
     *
     * @param key The key to delete
     */
    deleteMetadata(key: string): void;
    /**
     * Returns some metadata associated with the notebook.
     *
     * If no `key` is provided, it will return all metadata.
     * Else it will return the value for that key.
     *
     * @param key Key to get from the metadata
     * @returns Notebook's metadata.
     */
    getMetadata(): nbformat.INotebookMetadata;
    getMetadata(key: string): PartialJSONValue | undefined;
    /**
     * Sets some metadata associated with the notebook.
     *
     * If only one argument is provided, it will override all notebook metadata.
     * Otherwise a single key will be set to a new value.
     *
     * @param metadata All Notebook's metadata or the key to set.
     * @param value New metadata value
     */
    setMetadata(metadata: nbformat.INotebookMetadata): void;
    setMetadata(metadata: string, value: PartialJSONValue): void;
    /**
     * Updates the metadata associated with the notebook.
     *
     * @param value: Metadata's attribute to update.
     */
    updateMetadata(value: Partial<nbformat.INotebookMetadata>): void;
    /**
     * Override the notebook with a JSON-serialized document.
     *
     * @param value The notebook
     */
    fromJSON(value: nbformat.INotebookContent): void;
    /**
     * Serialize the model to JSON.
     */
    toJSON(): nbformat.INotebookContent;
    /**
     * Handle a change to the ystate.
     */
    private _onMetaChanged;
    /**
     * Handle a change to the list of cells.
     */
    private _onYCellsChanged;
    protected _metadataChanged: Signal<this, IMapChange<any>>;
    /**
     * Internal Yjs cells list
     */
    protected readonly _ycells: Y.Array<Y.Map<any>>;
    private _disableDocumentWideUndoRedo;
    private _ycellMapping;
}
export {};
