{"version":3,"sources":["webpack://@jupyterlab/application-top/./node_modules/@axlair/jupyterlab_vim/lib/codemirrorCommands.js","webpack://@jupyterlab/application-top/./node_modules/@axlair/jupyterlab_vim/lib/labCommands.js","webpack://@jupyterlab/application-top/./node_modules/@axlair/jupyterlab_vim/lib/index.js"],"names":["IS_MAC","navigator","platform","match","VimCellManager","constructor","commands","cm","enabled","userKeybindings","this","_commands","_cm","lastActiveCell","onActiveCellChanged","tracker","activeCell","modifyCell","editor","setOption","extraKeys","getOption","prototype","leaveInsertMode","save","execute","lcm","lvim","Vim","forEach","ctx","mapclear","command","keys","context","mapfn","keybindEnabled","map","noremap","defineEx","handleKey","moveByLinesOrCell","head","motionArgs","vim","cur","endCh","ch","currentCell","lastMotion","moveByLines","moveByDisplayLines","moveByScroll","moveToColumn","moveToEol","lastHPos","repeat","repeatOffset","line","forward","first","firstLine","last","lastLine","posV","findPosV","lastHSPos","hasMarkedText","model","type","handleArrow","rendered","cursor","getCursor","last_char","doc","getLine","length","setCursor","findFirstNonWhiteSpaceCharacter","text","firstNonWS","search","toFirstChar","charCoords","Pos","left","defineMotion","mapCommand","linewise","defineAction","actionArgs","extra","addJLabCommands","app","CodeMirror","shell","getCurrent","args","widget","currentWidget","activate","activateById","id","isEnabled","addedCommands","addCommand","label","current","content","NotebookActions","sessionContext","mode","state","insertMode","visualMode","activeCellIndex","deselectAll","ElementExt","node","widgets","er","inputArea","getBoundingClientRect","scrollToPosition","bottom","PLUGIN_NAME","TOGGLE_ID","extension","autoStart","activateCellVim","requires","INotebookTracker","ICodeMirror","ISettingRegistry","async","jlabCodeMirror","settingRegistry","set","isToggled","get","composite","globalCodeMirror","cellManager","escBinding","hasEverBeenEnabled","activeCellChanged","connect","updateSettings","settings","notifyCommandChanged","dispose","restored","ensureVimKeymap","addKeyBinding","selector","notebook","dataset","jpVimMode","widgetAdded","sender","load","then","changed","err","console","error","Promise","resolve"],"mappings":"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","file":"6607.117b9fae6fbeec23f3f3.js?v=117b9fae6fbeec23f3f3","sourcesContent":["/**\n * A boolean indicating whether the platform is Mac.\n */\nconst IS_MAC = !!navigator.platform.match(/Mac/i);\nexport class VimCellManager {\n    constructor({ commands, cm, enabled, userKeybindings }) {\n        this._commands = commands;\n        this._cm = cm;\n        this.enabled = enabled;\n        this.lastActiveCell = null;\n        this.userKeybindings = userKeybindings !== null && userKeybindings !== void 0 ? userKeybindings : [];\n    }\n    onActiveCellChanged(tracker, activeCell) {\n        this.modifyCell(activeCell);\n    }\n    modifyCell(activeCell) {\n        if (!activeCell) {\n            return;\n        }\n        this.lastActiveCell = activeCell;\n        const editor = activeCell.editor;\n        if (this.enabled) {\n            editor.setOption('keyMap', 'vim');\n            const extraKeys = editor.getOption('extraKeys') || {};\n            // TODO: does can this be any codemirror?\n            extraKeys['Esc'] = this._cm.prototype.leaveInsertMode;\n            if (!IS_MAC) {\n                extraKeys['Ctrl-C'] = false;\n            }\n            this._cm.prototype.save = () => {\n                this._commands.execute('docmanager:save');\n            };\n            editor.setOption('extraKeys', extraKeys);\n            const lcm = this._cm;\n            const lvim = lcm.Vim;\n            // Clear existing user keybindings, then re-register in case they changed in the user settings\n            ['normal', 'visual', 'insert'].forEach(ctx => lvim.mapclear(ctx));\n            this.userKeybindings.forEach(({ command, keys, context, mapfn, enabled: keybindEnabled }) => {\n                if (keybindEnabled) {\n                    if (mapfn === 'map') {\n                        lvim.map(command, keys, context);\n                    }\n                    else {\n                        lvim.noremap(command, keys, context);\n                    }\n                }\n            });\n            lvim.defineEx('quit', 'q', (cm) => {\n                this._commands.execute('notebook:enter-command-mode');\n            });\n            this._cm.Vim.handleKey(editor.editor, '<Esc>');\n            // Define a function to use as Vim motion\n            // This replaces the codemirror moveByLines function to\n            // for jumping between notebook cells.\n            const moveByLinesOrCell = (cm, head, motionArgs, vim) => {\n                const cur = head;\n                let endCh = cur.ch;\n                const currentCell = activeCell;\n                // TODO: these references will be undefined\n                // Depending what our last motion was, we may want to do different\n                // things. If our last motion was moving vertically, we want to\n                // preserve the HPos from our last horizontal move.  If our last motion\n                // was going to the end of a line, moving vertically we should go to\n                // the end of the line, etc.\n                switch (vim === null || vim === void 0 ? void 0 : vim.lastMotion) {\n                    case cm.moveByLines:\n                    case cm.moveByDisplayLines:\n                    case cm.moveByScroll:\n                    case cm.moveToColumn:\n                    case cm.moveToEol:\n                    // JUPYTER PATCH: add our custom method to the motion cases\n                    // eslint-disable-next-line no-fallthrough\n                    case moveByLinesOrCell:\n                        endCh = vim.lastHPos;\n                        break;\n                    default:\n                        vim.lastHPos = endCh;\n                }\n                const repeat = motionArgs.repeat + (motionArgs.repeatOffset || 0);\n                let line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;\n                const first = cm.firstLine();\n                const last = cm.lastLine();\n                const posV = cm.findPosV(cur, motionArgs.forward ? repeat : -repeat, 'line', vim.lastHSPos);\n                const hasMarkedText = motionArgs.forward\n                    ? posV.line > line\n                    : posV.line < line;\n                if (hasMarkedText) {\n                    line = posV.line;\n                    endCh = posV.ch;\n                }\n                // JUPYTER PATCH BEGIN\n                // here we insert the jumps to the next cells\n                if (line < first || line > last) {\n                    // var currentCell = ns.notebook.get_selected_cell();\n                    // var currentCell = tracker.activeCell;\n                    // var key = '';\n                    // `currentCell !== null should not be needed since `activeCell`\n                    // is already check against null (row 61). Added to avoid warning.\n                    if (currentCell !== null && currentCell.model.type === 'markdown') {\n                        if (!motionArgs.handleArrow) {\n                            // markdown cells tends to improperly handle arrow keys movement,\n                            //  on the way up the cell is rendered, but down movement is ignored\n                            //  when use arrows the cell will remain unrendered (need to shift+enter)\n                            //  However, this is the same as Jupyter default behaviour\n                            currentCell.rendered = true;\n                        }\n                        // currentCell.execute();\n                    }\n                    if (motionArgs.forward) {\n                        // ns.notebook.select_next();\n                        if (!motionArgs.handleArrow) {\n                            this._commands.execute('notebook:move-cursor-down');\n                        }\n                        else {\n                            // This block preventing double cell hop when you use arrow keys for navigation\n                            //    also arrow key navigation works properly when current cursor position\n                            //    at the beginning of line for up move, and at the end for down move\n                            const cursor = cm.getCursor();\n                            const last_char = cm.doc.getLine(last).length;\n                            if (cursor.line !== last || cursor.ch !== last_char) {\n                                cm.setCursor({ line: last, ch: last_char });\n                                this._commands.execute('notebook:move-cursor-down');\n                            }\n                        }\n                        // key = 'j';\n                    }\n                    else {\n                        // ns.notebook.select_prev();\n                        if (!motionArgs.handleArrow) {\n                            this._commands.execute('notebook:move-cursor-up');\n                        }\n                        else {\n                            // This block preventing double cell hop when you use arrow keys for navigation\n                            //    also arrow key navigation works properly when current cursor position\n                            //    at the beginning of line for up move, and at the end for down move\n                            const cursor = cm.getCursor();\n                            if (cursor.line !== 0 || cursor.ch !== 0) {\n                                cm.setCursor({ line: 0, ch: 0 });\n                                this._commands.execute('notebook:move-cursor-up');\n                            }\n                        }\n                        // key = 'k';\n                    }\n                    return;\n                }\n                // JUPYTER PATCH END\n                // function taken from https://github.com/codemirror/CodeMirror/blob/9d0f9d19de70abe817e8b8e161034fbd3f907030/keymap/vim.js#L3328\n                function findFirstNonWhiteSpaceCharacter(text) {\n                    if (!text) {\n                        return 0;\n                    }\n                    const firstNonWS = text.search(/\\S/);\n                    return firstNonWS === -1 ? text.length : firstNonWS;\n                }\n                if (motionArgs.toFirstChar) {\n                    endCh = findFirstNonWhiteSpaceCharacter(cm.getLine(line));\n                    vim.lastHPos = endCh;\n                }\n                vim.lastHSPos = cm.charCoords(this._cm.Pos(line, endCh), 'div').left;\n                return this._cm.Pos(line, endCh);\n            };\n            lvim.defineMotion('moveByLinesOrCell', moveByLinesOrCell);\n            lvim.mapCommand('<Up>', 'motion', 'moveByLinesOrCell', { forward: false, linewise: true, handleArrow: true }, { context: 'normal' });\n            lvim.mapCommand('<Down>', 'motion', 'moveByLinesOrCell', { forward: true, linewise: true, handleArrow: true }, { context: 'normal' });\n            lvim.mapCommand('k', 'motion', 'moveByLinesOrCell', { forward: false, linewise: true }, { context: 'normal' });\n            lvim.mapCommand('j', 'motion', 'moveByLinesOrCell', { forward: true, linewise: true }, { context: 'normal' });\n            lvim.defineAction('moveCellDown', (cm, actionArgs) => {\n                this._commands.execute('notebook:move-cell-down');\n            });\n            lvim.defineAction('moveCellUp', (cm, actionArgs) => {\n                this._commands.execute('notebook:move-cell-up');\n            });\n            lvim.mapCommand('<C-e>', 'action', 'moveCellDown', {}, { extra: 'normal' });\n            lvim.mapCommand('<C-y>', 'action', 'moveCellUp', {}, { extra: 'normal' });\n            lvim.defineAction('splitCell', (cm, actionArgs) => {\n                this._commands.execute('notebook:split-cell-at-cursor');\n            });\n            lvim.mapCommand('-', 'action', 'splitCell', {}, { extra: 'normal' });\n        }\n        else if (editor.getOption('keyMap') === 'vim') {\n            editor.setOption('keyMap', 'default');\n        }\n    }\n}\n","import { NotebookActions } from '@jupyterlab/notebook';\nimport { ElementExt } from '@lumino/domutils';\nexport function addJLabCommands(app, tracker, CodeMirror) {\n    const { commands, shell } = app;\n    function getCurrent(args) {\n        const widget = tracker.currentWidget;\n        const activate = args['activate'] !== false;\n        if (activate && widget) {\n            shell.activateById(widget.id);\n        }\n        return widget;\n    }\n    function isEnabled() {\n        return (tracker.currentWidget !== null &&\n            tracker.currentWidget === app.shell.currentWidget);\n    }\n    const addedCommands = [\n        commands.addCommand('vim:run-select-next-edit', {\n            label: 'Run Cell and Edit Next Cell',\n            execute: args => {\n                const current = getCurrent(args);\n                if (current) {\n                    const { context, content } = current;\n                    NotebookActions.runAndAdvance(content, context.sessionContext);\n                    current.content.mode = 'edit';\n                }\n            },\n            isEnabled\n        }),\n        commands.addCommand('vim:run-cell-and-edit', {\n            label: 'Run Cell and Edit Cell',\n            execute: args => {\n                const current = getCurrent(args);\n                if (current) {\n                    const { context, content } = current;\n                    NotebookActions.run(content, context.sessionContext);\n                    current.content.mode = 'edit';\n                }\n            },\n            isEnabled\n        }),\n        commands.addCommand('vim:cut-cell-and-edit', {\n            label: 'Cut Cell(s) and Edit Cell',\n            execute: args => {\n                const current = getCurrent(args);\n                if (current) {\n                    const { content } = current;\n                    NotebookActions.cut(content);\n                    content.mode = 'edit';\n                }\n            },\n            isEnabled\n        }),\n        commands.addCommand('vim:copy-cell-and-edit', {\n            label: 'Copy Cell(s) and Edit Cell',\n            execute: args => {\n                const current = getCurrent(args);\n                if (current) {\n                    const { content } = current;\n                    NotebookActions.copy(content);\n                    content.mode = 'edit';\n                }\n            },\n            isEnabled\n        }),\n        commands.addCommand('vim:paste-cell-and-edit', {\n            label: 'Paste Cell(s) and Edit Cell',\n            execute: args => {\n                const current = getCurrent(args);\n                if (current) {\n                    const { content } = current;\n                    NotebookActions.paste(content, 'below');\n                    content.mode = 'edit';\n                }\n            },\n            isEnabled\n        }),\n        commands.addCommand('vim:merge-and-edit', {\n            label: 'Merge and Edit Cell',\n            execute: args => {\n                const current = getCurrent(args);\n                if (current) {\n                    const { content } = current;\n                    NotebookActions.mergeCells(content);\n                    current.content.mode = 'edit';\n                }\n            },\n            isEnabled\n        }),\n        commands.addCommand('vim:enter-insert-mode', {\n            label: 'Enter Insert Mode',\n            execute: args => {\n                const current = getCurrent(args);\n                if (current) {\n                    const { content } = current;\n                    if (content.activeCell !== null) {\n                        const editor = content.activeCell.editor;\n                        current.content.mode = 'edit';\n                        CodeMirror.Vim.handleKey(editor.editor, 'i');\n                    }\n                }\n            },\n            isEnabled\n        }),\n        commands.addCommand('vim:leave-insert-mode', {\n            label: 'Leave Insert Mode',\n            execute: args => {\n                const current = getCurrent(args);\n                if (current) {\n                    const { content } = current;\n                    if (content.activeCell !== null) {\n                        const editor = content.activeCell.editor;\n                        CodeMirror.Vim.handleKey(editor.editor, '<Esc>');\n                    }\n                }\n            },\n            isEnabled\n        }),\n        commands.addCommand('vim:leave-current-mode', {\n            label: 'Move Insert to Normal to Jupyter Command Mode\"',\n            execute: args => {\n                const current = getCurrent(args);\n                if (current) {\n                    const { content } = current;\n                    if (content.activeCell !== null) {\n                        const editor = content.activeCell.editor;\n                        // Get the current editor state\n                        if (editor.editor.state.vim.insertMode ||\n                            editor.editor.state.vim.visualMode) {\n                            CodeMirror.Vim.handleKey(editor.editor, '<Esc>');\n                        }\n                        else {\n                            commands.execute('notebook:enter-command-mode');\n                        }\n                    }\n                }\n            },\n            isEnabled\n        }),\n        commands.addCommand('vim:select-below-execute-markdown', {\n            label: 'Execute Markdown and Select Cell Below',\n            execute: args => {\n                const current = getCurrent(args);\n                if (current) {\n                    const { content } = current;\n                    if (content.activeCell !== null &&\n                        content.activeCell.model.type === 'markdown') {\n                        current.content.activeCell.rendered = true;\n                    }\n                    return NotebookActions.selectBelow(current.content);\n                }\n            },\n            isEnabled\n        }),\n        commands.addCommand('vim:select-above-execute-markdown', {\n            label: 'Execute Markdown and Select Cell Below',\n            execute: args => {\n                const current = getCurrent(args);\n                if (current) {\n                    const { content } = current;\n                    if (content.activeCell !== null &&\n                        content.activeCell.model.type === 'markdown') {\n                        current.content.activeCell.rendered = true;\n                    }\n                    return NotebookActions.selectAbove(current.content);\n                }\n            },\n            isEnabled\n        }),\n        commands.addCommand('vim:select-first-cell', {\n            label: 'Select First Cell',\n            execute: args => {\n                const current = getCurrent(args);\n                if (current) {\n                    const { content } = current;\n                    content.activeCellIndex = 0;\n                    content.deselectAll();\n                    if (content.activeCell !== null) {\n                        ElementExt.scrollIntoViewIfNeeded(content.node, content.activeCell.node);\n                    }\n                }\n            },\n            isEnabled\n        }),\n        commands.addCommand('vim:select-last-cell', {\n            label: 'Select Last Cell',\n            execute: args => {\n                const current = getCurrent(args);\n                if (current) {\n                    const { content } = current;\n                    content.activeCellIndex = current.content.widgets.length - 1;\n                    content.deselectAll();\n                    if (content.activeCell !== null) {\n                        ElementExt.scrollIntoViewIfNeeded(content.node, content.activeCell.node);\n                    }\n                }\n            },\n            isEnabled\n        }),\n        commands.addCommand('vim:center-cell', {\n            label: 'Center Cell',\n            execute: args => {\n                const current = getCurrent(args);\n                if (current && current.content.activeCell !== null) {\n                    const er = current.content.activeCell.inputArea.node.getBoundingClientRect();\n                    current.content.scrollToPosition(er.bottom, 0);\n                }\n            },\n            isEnabled\n        })\n    ];\n    return addedCommands;\n}\n","import { INotebookTracker } from '@jupyterlab/notebook';\nimport { ICodeMirror } from '@jupyterlab/codemirror';\nimport { ISettingRegistry } from '@jupyterlab/settingregistry';\nimport { VimCellManager } from './codemirrorCommands';\nimport { addJLabCommands } from './labCommands';\nconst PLUGIN_NAME = '@axlair/jupyterlab_vim';\nconst TOGGLE_ID = 'jupyterlab-vim:toggle';\nlet enabled = false;\n/**\n * Initialization data for the jupyterlab_vim extension.\n */\nconst extension = {\n    id: PLUGIN_NAME,\n    autoStart: true,\n    activate: activateCellVim,\n    requires: [INotebookTracker, ICodeMirror, ISettingRegistry]\n};\nasync function activateCellVim(app, tracker, jlabCodeMirror, settingRegistry) {\n    // await app.restored;\n    app.commands.addCommand(TOGGLE_ID, {\n        label: 'Enable Notebook Vim mode',\n        execute: () => {\n            if (settingRegistry) {\n                void settingRegistry.set(`${PLUGIN_NAME}:plugin`, 'enabled', !enabled);\n            }\n        },\n        isToggled: () => enabled\n    });\n    const userKeybindings = (await settingRegistry.get(`${PLUGIN_NAME}:plugin`, 'extraKeybindings')).composite;\n    // eslint-disable-next-line prettier/prettier\n    const globalCodeMirror = jlabCodeMirror.CodeMirror;\n    let cellManager = null;\n    let escBinding = null;\n    let hasEverBeenEnabled = false;\n    cellManager = new VimCellManager({\n        commands: app.commands,\n        cm: globalCodeMirror,\n        enabled,\n        userKeybindings\n    });\n    // it's ok to connect here because we will never reach the vim section unless\n    // ensureVimKeyMap has been called due to the checks for enabled.\n    // we need to have now in order to keep track of the last active cell\n    // so that we can modify it when vim is turned on or off.\n    tracker.activeCellChanged.connect(cellManager.onActiveCellChanged, cellManager);\n    addJLabCommands(app, tracker, globalCodeMirror);\n    async function updateSettings(settings) {\n        const userKeybindings = (await settingRegistry.get(`${PLUGIN_NAME}:plugin`, 'extraKeybindings')).composite;\n        enabled = settings.get('enabled').composite === true;\n        app.commands.notifyCommandChanged(TOGGLE_ID);\n        if (cellManager) {\n            cellManager.enabled = enabled;\n            cellManager.userKeybindings = userKeybindings;\n        }\n        if (enabled) {\n            escBinding === null || escBinding === void 0 ? void 0 : escBinding.dispose();\n            if (!hasEverBeenEnabled) {\n                hasEverBeenEnabled = true;\n                await app.restored;\n                await jlabCodeMirror.ensureVimKeymap();\n            }\n        }\n        else {\n            escBinding = app.commands.addKeyBinding({\n                command: 'notebook:enter-command-mode',\n                keys: ['Escape'],\n                selector: '.jp-Notebook.jp-mod-editMode'\n            });\n        }\n        tracker.forEach(notebook => {\n            notebook.node.dataset.jpVimMode = `${enabled}`;\n        });\n        cellManager === null || cellManager === void 0 ? void 0 : cellManager.modifyCell(cellManager.lastActiveCell);\n        // make sure our css selector is added to new notebooks\n        tracker.widgetAdded.connect((sender, notebook) => {\n            notebook.node.dataset.jpVimMode = `${enabled}`;\n        });\n    }\n    settingRegistry.load(`${PLUGIN_NAME}:plugin`).then((settings) => {\n        updateSettings(settings);\n        settings.changed.connect(updateSettings);\n    }, (err) => {\n        console.error(`Could not load settings, so did not active ${PLUGIN_NAME}: ${err}`);\n    });\n    return Promise.resolve();\n}\nexport default extension;\n"],"sourceRoot":""}