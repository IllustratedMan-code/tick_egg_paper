{"version":3,"sources":["webpack://@jupyterlab/application-top/./node_modules/lib0/binary.js","webpack://@jupyterlab/application-top/./node_modules/lib0/buffer.js","webpack://@jupyterlab/application-top/./node_modules/lib0/decoding.js","webpack://@jupyterlab/application-top/./node_modules/lib0/encoding.js","webpack://@jupyterlab/application-top/./node_modules/lib0/conditions.js","webpack://@jupyterlab/application-top/./node_modules/lib0/environment.js","webpack://@jupyterlab/application-top/./node_modules/lib0/number.js","webpack://@jupyterlab/application-top/./node_modules/lib0/storage.js","webpack://@jupyterlab/application-top/./node_modules/lib0/string.js","webpack://@jupyterlab/application-top/./node_modules/lib0/time.js","webpack://@jupyterlab/application-top/./node_modules/process/browser.js"],"names":["BIT1","BIT2","BIT3","BIT4","BIT5","BIT6","BIT7","BIT8","BIT9","BIT10","BIT11","BIT12","BIT13","BIT14","BIT15","BIT16","BIT17","BIT18","BIT19","BIT20","BIT21","BIT22","BIT23","BIT24","BIT25","BIT26","BIT27","BIT28","BIT29","BIT30","BIT31","BIT32","BITS0","BITS1","BITS2","BITS3","BITS4","BITS5","BITS6","BITS7","BITS8","BITS9","BITS10","BITS11","BITS12","BITS13","BITS14","BITS15","BITS16","BITS17","BITS18","BITS19","BITS20","BITS21","BITS22","BITS23","BITS24","BITS25","BITS26","BITS27","BITS28","BITS29","BITS30","BITS31","BITS32","createUint8ArrayFromLen","len","Uint8Array","createUint8ArrayViewFromArrayBuffer","buffer","byteOffset","length","createUint8ArrayFromArrayBuffer","toBase64Browser","bytes","s","i","byteLength","btoa","toBase64Node","Buffer","from","toString","fromBase64Browser","a","atob","charCodeAt","fromBase64Node","buf","toBase64","fromBase64","copyUint8Array","uint8Array","newBuf","set","encodeAny","data","encoder","encoding","createEncoder","writeAny","toUint8Array","decodeAny","decoding","readAny","createDecoder","Decoder","constructor","this","arr","pos","hasContent","decoder","clone","newPos","_decoder","readUint8Array","view","readVarUint8Array","readVarUint","readTailAsUint8Array","skip8","readUint8","readUint16","uint","readUint32","readUint32BigEndian","peekUint8","peekUint16","peekUint32","num","mult","r","Error","readVarInt","sign","peekVarUint","peekVarInt","_readVarStringPolyfill","remainingLen","encodedString","String","fromCodePoint","nextLen","subarray","apply","decodeURIComponent","escape","_readVarStringNative","readVarString","peekVarString","readFromDataView","dv","DataView","readFloat32","getFloat32","readFloat64","getFloat64","readBigInt64","getBigInt64","readBigUint64","getBigUint64","readAnyLookupTable","undefined","obj","key","push","RleDecoder","reader","super","count","read","IntDiffDecoder","start","RleIntDiffDecoder","UintOptRleDecoder","isNegative","IncUintOptRleDecoder","math","isNegativeZero","IntDiffOptRleDecoder","diff","hasCount","StringDecoder","str","spos","end","res","slice","Encoder","cpos","cbuf","bufs","uint8arr","curPos","d","verifyLen","bufferLen","write","b","writeUint8","setUint8","writeUint16","binary","setUint16","writeUint32","writeUint32BigEndian","setUint32","writeVarUint","writeVarInt","_strBuffer","_maxStrBSize","_writeVarStringNative","written","writeVarUint8Array","_writeVarStringPolyfill","unescape","encodeURIComponent","codePointAt","writeVarString","writeBinaryEncoder","append","writeUint8Array","leftCopyLen","rightCopyLen","writeOnDataView","dview","writeFloat32","setFloat32","writeFloat64","setFloat64","writeBigInt64","setBigInt64","writeBigUint64","setBigUint64","floatTestBed","ArrayBuffer","isFloat32","Array","keys","Object","RleEncoder","writer","w","v","IntDiffEncoder","RleIntDiffEncoder","flushUintOptRleEncoder","UintOptRleEncoder","IncUintOptRleEncoder","flushIntDiffOptRleEncoder","encodedDiff","IntDiffOptRleEncoder","StringEncoder","sarr","lensE","string","join","undefinedToNull","isNode","process","release","test","name","isBrowser","window","isMac","navigator","platform","params","args","computeParams","map","pargs","argv","currParamName","parg","location","search","split","forEach","kv","value","hasParam","has","getParam","defaultVal","get","getVariable","env","toUpperCase","storage","getConf","hasConf","production","forceColor","FORCE_COLOR","supportsColor","stdout","isTTY","includes","MAX_SAFE_INTEGER","Number","MIN_SAFE_INTEGER","LOWEST_INT32","HIGHEST_INT32","isInteger","isFinite","isNaN","parseInt","VarStoragePolyfill","Map","setItem","newValue","getItem","_localStorage","usePolyfill","localStorage","e","varStorage","onChange","eventHandler","addEventListener","fromCharCode","toLowerCase","trimLeftRegex","trimLeft","replace","fromCamelCaseRegex","fromCamelCase","separator","match","utf8ByteLength","_encodeUtf8Polyfill","utf8TextEncoder","TextEncoder","_encodeUtf8Native","encode","encodeUtf8","_decodeUtf8Polyfill","bufPos","utf8TextDecoder","TextDecoder","fatal","ignoreBOM","decode","_decodeUtf8Native","decodeUtf8","splice","index","remove","insert","getDate","Date","getUnixTime","now","humanizeDuration","p","metric","prefix","round","n","floor","seconds","minutes","hours","days","module","exports","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","defaultClearTimeout","setTimeout","clearTimeout","runTimeout","fun","call","runClearTimeout","marker","queue","draining","currentQueue","queueIndex","cleanUpNextTick","concat","drainQueue","timeout","run","nextTick","arguments","Item","array","prototype","title","browser","version","versions","noop","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask"],"mappings":"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","file":"4657.8562f70714e36dc33542.js?v=8562f70714e36dc33542","sourcesContent":["/* eslint-env browser */\n\n/**\n * Binary data constants.\n *\n * @module binary\n */\n\n/**\n * n-th bit activated.\n *\n * @type {number}\n */\nexport const BIT1 = 1\nexport const BIT2 = 2\nexport const BIT3 = 4\nexport const BIT4 = 8\nexport const BIT5 = 16\nexport const BIT6 = 32\nexport const BIT7 = 64\nexport const BIT8 = 128\nexport const BIT9 = 256\nexport const BIT10 = 512\nexport const BIT11 = 1024\nexport const BIT12 = 2048\nexport const BIT13 = 4096\nexport const BIT14 = 8192\nexport const BIT15 = 16384\nexport const BIT16 = 32768\nexport const BIT17 = 65536\nexport const BIT18 = 1 << 17\nexport const BIT19 = 1 << 18\nexport const BIT20 = 1 << 19\nexport const BIT21 = 1 << 20\nexport const BIT22 = 1 << 21\nexport const BIT23 = 1 << 22\nexport const BIT24 = 1 << 23\nexport const BIT25 = 1 << 24\nexport const BIT26 = 1 << 25\nexport const BIT27 = 1 << 26\nexport const BIT28 = 1 << 27\nexport const BIT29 = 1 << 28\nexport const BIT30 = 1 << 29\nexport const BIT31 = 1 << 30\nexport const BIT32 = 1 << 31\n\n/**\n * First n bits activated.\n *\n * @type {number}\n */\nexport const BITS0 = 0\nexport const BITS1 = 1\nexport const BITS2 = 3\nexport const BITS3 = 7\nexport const BITS4 = 15\nexport const BITS5 = 31\nexport const BITS6 = 63\nexport const BITS7 = 127\nexport const BITS8 = 255\nexport const BITS9 = 511\nexport const BITS10 = 1023\nexport const BITS11 = 2047\nexport const BITS12 = 4095\nexport const BITS13 = 8191\nexport const BITS14 = 16383\nexport const BITS15 = 32767\nexport const BITS16 = 65535\nexport const BITS17 = BIT18 - 1\nexport const BITS18 = BIT19 - 1\nexport const BITS19 = BIT20 - 1\nexport const BITS20 = BIT21 - 1\nexport const BITS21 = BIT22 - 1\nexport const BITS22 = BIT23 - 1\nexport const BITS23 = BIT24 - 1\nexport const BITS24 = BIT25 - 1\nexport const BITS25 = BIT26 - 1\nexport const BITS26 = BIT27 - 1\nexport const BITS27 = BIT28 - 1\nexport const BITS28 = BIT29 - 1\nexport const BITS29 = BIT30 - 1\nexport const BITS30 = BIT31 - 1\n/**\n * @type {number}\n */\nexport const BITS31 = 0x7FFFFFFF\n/**\n * @type {number}\n */\nexport const BITS32 = 0xFFFFFFFF\n","/**\n * Utility functions to work with buffers (Uint8Array).\n *\n * @module buffer\n */\n\nimport * as string from './string.js'\nimport * as env from './environment.js'\nimport * as encoding from './encoding.js'\nimport * as decoding from './decoding.js'\n\n/**\n * @param {number} len\n */\nexport const createUint8ArrayFromLen = len => new Uint8Array(len)\n\n/**\n * Create Uint8Array with initial content from buffer\n *\n * @param {ArrayBuffer} buffer\n * @param {number} byteOffset\n * @param {number} length\n */\nexport const createUint8ArrayViewFromArrayBuffer = (buffer, byteOffset, length) => new Uint8Array(buffer, byteOffset, length)\n\n/**\n * Create Uint8Array with initial content from buffer\n *\n * @param {ArrayBuffer} buffer\n */\nexport const createUint8ArrayFromArrayBuffer = buffer => new Uint8Array(buffer)\n\n/* istanbul ignore next */\n/**\n * @param {Uint8Array} bytes\n * @return {string}\n */\nconst toBase64Browser = bytes => {\n  let s = ''\n  for (let i = 0; i < bytes.byteLength; i++) {\n    s += string.fromCharCode(bytes[i])\n  }\n  // eslint-disable-next-line no-undef\n  return btoa(s)\n}\n\n/**\n * @param {Uint8Array} bytes\n * @return {string}\n */\nconst toBase64Node = bytes => Buffer.from(bytes.buffer, bytes.byteOffset, bytes.byteLength).toString('base64')\n\n/* istanbul ignore next */\n/**\n * @param {string} s\n * @return {Uint8Array}\n */\nconst fromBase64Browser = s => {\n  // eslint-disable-next-line no-undef\n  const a = atob(s)\n  const bytes = createUint8ArrayFromLen(a.length)\n  for (let i = 0; i < a.length; i++) {\n    bytes[i] = a.charCodeAt(i)\n  }\n  return bytes\n}\n\n/**\n * @param {string} s\n */\nconst fromBase64Node = s => {\n  const buf = Buffer.from(s, 'base64')\n  return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength)\n}\n\n/* istanbul ignore next */\nexport const toBase64 = env.isBrowser ? toBase64Browser : toBase64Node\n\n/* istanbul ignore next */\nexport const fromBase64 = env.isBrowser ? fromBase64Browser : fromBase64Node\n\n/**\n * Copy the content of an Uint8Array view to a new ArrayBuffer.\n *\n * @param {Uint8Array} uint8Array\n * @return {Uint8Array}\n */\nexport const copyUint8Array = uint8Array => {\n  const newBuf = createUint8ArrayFromLen(uint8Array.byteLength)\n  newBuf.set(uint8Array)\n  return newBuf\n}\n\n/**\n * Encode anything as a UInt8Array. It's a pun on typescripts's `any` type.\n * See encoding.writeAny for more information.\n *\n * @param {any} data\n * @return {Uint8Array}\n */\nexport const encodeAny = data => {\n  const encoder = encoding.createEncoder()\n  encoding.writeAny(encoder, data)\n  return encoding.toUint8Array(encoder)\n}\n\n/**\n * Decode an any-encoded value.\n *\n * @param {Uint8Array} buf\n * @return {any}\n */\nexport const decodeAny = buf => decoding.readAny(decoding.createDecoder(buf))\n","/**\n * Efficient schema-less binary decoding with support for variable length encoding.\n *\n * Use [lib0/decoding] with [lib0/encoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = new encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, 'Hello world!')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = new decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => 'Hello world!'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module decoding\n */\n\nimport * as buffer from './buffer.js'\nimport * as binary from './binary.js'\nimport * as math from './math.js'\nimport * as number from './number.js'\nimport * as string from './string.js'\n\n/**\n * A Decoder handles the decoding of an Uint8Array.\n */\nexport class Decoder {\n  /**\n   * @param {Uint8Array} uint8Array Binary data to decode\n   */\n  constructor (uint8Array) {\n    /**\n     * Decoding target.\n     *\n     * @type {Uint8Array}\n     */\n    this.arr = uint8Array\n    /**\n     * Current decoding position.\n     *\n     * @type {number}\n     */\n    this.pos = 0\n  }\n}\n\n/**\n * @function\n * @param {Uint8Array} uint8Array\n * @return {Decoder}\n */\nexport const createDecoder = uint8Array => new Decoder(uint8Array)\n\n/**\n * @function\n * @param {Decoder} decoder\n * @return {boolean}\n */\nexport const hasContent = decoder => decoder.pos !== decoder.arr.length\n\n/**\n * Clone a decoder instance.\n * Optionally set a new position parameter.\n *\n * @function\n * @param {Decoder} decoder The decoder instance\n * @param {number} [newPos] Defaults to current position\n * @return {Decoder} A clone of `decoder`\n */\nexport const clone = (decoder, newPos = decoder.pos) => {\n  const _decoder = createDecoder(decoder.arr)\n  _decoder.pos = newPos\n  return _decoder\n}\n\n/**\n * Create an Uint8Array view of the next `len` bytes and advance the position by `len`.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder The decoder instance\n * @param {number} len The length of bytes to read\n * @return {Uint8Array}\n */\nexport const readUint8Array = (decoder, len) => {\n  const view = buffer.createUint8ArrayViewFromArrayBuffer(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len)\n  decoder.pos += len\n  return view\n}\n\n/**\n * Read variable length Uint8Array.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nexport const readVarUint8Array = decoder => readUint8Array(decoder, readVarUint(decoder))\n\n/**\n * Read the rest of the content as an ArrayBuffer\n * @function\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nexport const readTailAsUint8Array = decoder => readUint8Array(decoder, decoder.arr.length - decoder.pos)\n\n/**\n * Skip one byte, jump to the next position.\n * @function\n * @param {Decoder} decoder The decoder instance\n * @return {number} The next position\n */\nexport const skip8 = decoder => decoder.pos++\n\n/**\n * Read one byte as unsigned integer.\n * @function\n * @param {Decoder} decoder The decoder instance\n * @return {number} Unsigned 8-bit integer\n */\nexport const readUint8 = decoder => decoder.arr[decoder.pos++]\n\n/**\n * Read 2 bytes as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const readUint16 = decoder => {\n  const uint =\n    decoder.arr[decoder.pos] +\n    (decoder.arr[decoder.pos + 1] << 8)\n  decoder.pos += 2\n  return uint\n}\n\n/**\n * Read 4 bytes as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const readUint32 = decoder => {\n  const uint =\n    (decoder.arr[decoder.pos] +\n    (decoder.arr[decoder.pos + 1] << 8) +\n    (decoder.arr[decoder.pos + 2] << 16) +\n    (decoder.arr[decoder.pos + 3] << 24)) >>> 0\n  decoder.pos += 4\n  return uint\n}\n\n/**\n * Read 4 bytes as unsigned integer in big endian order.\n * (most significant byte first)\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const readUint32BigEndian = decoder => {\n  const uint =\n    (decoder.arr[decoder.pos + 3] +\n    (decoder.arr[decoder.pos + 2] << 8) +\n    (decoder.arr[decoder.pos + 1] << 16) +\n    (decoder.arr[decoder.pos] << 24)) >>> 0\n  decoder.pos += 4\n  return uint\n}\n\n/**\n * Look ahead without incrementing the position\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const peekUint8 = decoder => decoder.arr[decoder.pos]\n\n/**\n * Look ahead without incrementing the position\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const peekUint16 = decoder =>\n  decoder.arr[decoder.pos] +\n  (decoder.arr[decoder.pos + 1] << 8)\n\n/**\n * Look ahead without incrementing the position\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const peekUint32 = decoder => (\n  decoder.arr[decoder.pos] +\n  (decoder.arr[decoder.pos + 1] << 8) +\n  (decoder.arr[decoder.pos + 2] << 16) +\n  (decoder.arr[decoder.pos + 3] << 24)\n) >>> 0\n\n/**\n * Read unsigned integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\nexport const readVarUint = decoder => {\n  let num = 0\n  let mult = 1\n  while (true) {\n    const r = decoder.arr[decoder.pos++]\n    // num = num | ((r & binary.BITS7) << len)\n    num = num + (r & binary.BITS7) * mult // shift $r << (7*#iterations) and add it to num\n    mult *= 128 // next iteration, shift 7 \"more\" to the left\n    if (r < binary.BIT8) {\n      return num\n    }\n    /* istanbul ignore if */\n    if (num > number.MAX_SAFE_INTEGER) {\n      throw new Error('Integer out of range!')\n    }\n  }\n}\n\n/**\n * Read signed integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n * @todo This should probably create the inverse ~num if number is negative - but this would be a breaking change.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\nexport const readVarInt = decoder => {\n  let r = decoder.arr[decoder.pos++]\n  let num = r & binary.BITS6\n  let mult = 64\n  const sign = (r & binary.BIT7) > 0 ? -1 : 1\n  if ((r & binary.BIT8) === 0) {\n    // don't continue reading\n    return sign * num\n  }\n  while (true) {\n    r = decoder.arr[decoder.pos++]\n    // num = num | ((r & binary.BITS7) << len)\n    num = num + (r & binary.BITS7) * mult\n    mult *= 128\n    if (r < binary.BIT8) {\n      return sign * num\n    }\n    /* istanbul ignore if */\n    if (num > number.MAX_SAFE_INTEGER) {\n      throw new Error('Integer out of range!')\n    }\n  }\n}\n\n/**\n * Look ahead and read varUint without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {number}\n */\nexport const peekVarUint = decoder => {\n  const pos = decoder.pos\n  const s = readVarUint(decoder)\n  decoder.pos = pos\n  return s\n}\n\n/**\n * Look ahead and read varUint without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {number}\n */\nexport const peekVarInt = decoder => {\n  const pos = decoder.pos\n  const s = readVarInt(decoder)\n  decoder.pos = pos\n  return s\n}\n\n/**\n * We don't test this function anymore as we use native decoding/encoding by default now.\n * Better not modify this anymore..\n *\n * Transforming utf8 to a string is pretty expensive. The code performs 10x better\n * when String.fromCodePoint is fed with all characters as arguments.\n * But most environments have a maximum number of arguments per functions.\n * For effiency reasons we apply a maximum of 10000 characters at once.\n *\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String.\n */\n/* istanbul ignore next */\nexport const _readVarStringPolyfill = decoder => {\n  let remainingLen = readVarUint(decoder)\n  if (remainingLen === 0) {\n    return ''\n  } else {\n    let encodedString = String.fromCodePoint(readUint8(decoder)) // remember to decrease remainingLen\n    if (--remainingLen < 100) { // do not create a Uint8Array for small strings\n      while (remainingLen--) {\n        encodedString += String.fromCodePoint(readUint8(decoder))\n      }\n    } else {\n      while (remainingLen > 0) {\n        const nextLen = remainingLen < 10000 ? remainingLen : 10000\n        // this is dangerous, we create a fresh array view from the existing buffer\n        const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen)\n        decoder.pos += nextLen\n        // Starting with ES5.1 we can supply a generic array-like object as arguments\n        encodedString += String.fromCodePoint.apply(null, /** @type {any} */ (bytes))\n        remainingLen -= nextLen\n      }\n    }\n    return decodeURIComponent(escape(encodedString))\n  }\n}\n\n/**\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String\n */\nexport const _readVarStringNative = decoder =>\n  /** @type any */ (string.utf8TextDecoder).decode(readVarUint8Array(decoder))\n\n/**\n * Read string of variable length\n * * varUint is used to store the length of the string\n *\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String\n *\n */\n/* istanbul ignore next */\nexport const readVarString = string.utf8TextDecoder ? _readVarStringNative : _readVarStringPolyfill\n\n/**\n * Look ahead and read varString without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {string}\n */\nexport const peekVarString = decoder => {\n  const pos = decoder.pos\n  const s = readVarString(decoder)\n  decoder.pos = pos\n  return s\n}\n\n/**\n * @param {Decoder} decoder\n * @param {number} len\n * @return {DataView}\n */\nexport const readFromDataView = (decoder, len) => {\n  const dv = new DataView(decoder.arr.buffer, decoder.arr.byteOffset + decoder.pos, len)\n  decoder.pos += len\n  return dv\n}\n\n/**\n * @param {Decoder} decoder\n */\nexport const readFloat32 = decoder => readFromDataView(decoder, 4).getFloat32(0, false)\n\n/**\n * @param {Decoder} decoder\n */\nexport const readFloat64 = decoder => readFromDataView(decoder, 8).getFloat64(0, false)\n\n/**\n * @param {Decoder} decoder\n */\nexport const readBigInt64 = decoder => /** @type {any} */ (readFromDataView(decoder, 8)).getBigInt64(0, false)\n\n/**\n * @param {Decoder} decoder\n */\nexport const readBigUint64 = decoder => /** @type {any} */ (readFromDataView(decoder, 8)).getBigUint64(0, false)\n\n/**\n * @type {Array<function(Decoder):any>}\n */\nconst readAnyLookupTable = [\n  decoder => undefined, // CASE 127: undefined\n  decoder => null, // CASE 126: null\n  readVarInt, // CASE 125: integer\n  readFloat32, // CASE 124: float32\n  readFloat64, // CASE 123: float64\n  readBigInt64, // CASE 122: bigint\n  decoder => false, // CASE 121: boolean (false)\n  decoder => true, // CASE 120: boolean (true)\n  readVarString, // CASE 119: string\n  decoder => { // CASE 118: object<string,any>\n    const len = readVarUint(decoder)\n    /**\n     * @type {Object<string,any>}\n     */\n    const obj = {}\n    for (let i = 0; i < len; i++) {\n      const key = readVarString(decoder)\n      obj[key] = readAny(decoder)\n    }\n    return obj\n  },\n  decoder => { // CASE 117: array<any>\n    const len = readVarUint(decoder)\n    const arr = []\n    for (let i = 0; i < len; i++) {\n      arr.push(readAny(decoder))\n    }\n    return arr\n  },\n  readVarUint8Array // CASE 116: Uint8Array\n]\n\n/**\n * @param {Decoder} decoder\n */\nexport const readAny = decoder => readAnyLookupTable[127 - readUint8(decoder)](decoder)\n\n/**\n * T must not be null.\n *\n * @template T\n */\nexport class RleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {function(Decoder):T} reader\n   */\n  constructor (uint8Array, reader) {\n    super(uint8Array)\n    /**\n     * The reader\n     */\n    this.reader = reader\n    /**\n     * Current state\n     * @type {T|null}\n     */\n    this.s = null\n    this.count = 0\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = this.reader(this)\n      if (hasContent(this)) {\n        this.count = readVarUint(this) + 1 // see encoder implementation for the reason why this is incremented\n      } else {\n        this.count = -1 // read the current value forever\n      }\n    }\n    this.count--\n    return /** @type {T} */ (this.s)\n  }\n}\n\nexport class IntDiffDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {number} start\n   */\n  constructor (uint8Array, start) {\n    super(uint8Array)\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    this.s += readVarInt(this)\n    return this.s\n  }\n}\n\nexport class RleIntDiffDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {number} start\n   */\n  constructor (uint8Array, start) {\n    super(uint8Array)\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n    this.count = 0\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    if (this.count === 0) {\n      this.s += readVarInt(this)\n      if (hasContent(this)) {\n        this.count = readVarUint(this) + 1 // see encoder implementation for the reason why this is incremented\n      } else {\n        this.count = -1 // read the current value forever\n      }\n    }\n    this.count--\n    return /** @type {number} */ (this.s)\n  }\n}\n\nexport class UintOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array)\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = readVarInt(this)\n      // if the sign is negative, we read the count too, otherwise count is 1\n      const isNegative = math.isNegativeZero(this.s)\n      this.count = 1\n      if (isNegative) {\n        this.s = -this.s\n        this.count = readVarUint(this) + 2\n      }\n    }\n    this.count--\n    return /** @type {number} */ (this.s)\n  }\n}\n\nexport class IncUintOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array)\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = readVarInt(this)\n      // if the sign is negative, we read the count too, otherwise count is 1\n      const isNegative = math.isNegativeZero(this.s)\n      this.count = 1\n      if (isNegative) {\n        this.s = -this.s\n        this.count = readVarUint(this) + 2\n      }\n    }\n    this.count--\n    return /** @type {number} */ (this.s++)\n  }\n}\n\nexport class IntDiffOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array)\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n    this.diff = 0\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    if (this.count === 0) {\n      const diff = readVarInt(this)\n      // if the first bit is set, we read more data\n      const hasCount = diff & 1\n      this.diff = math.floor(diff / 2) // shift >> 1\n      this.count = 1\n      if (hasCount) {\n        this.count = readVarUint(this) + 2\n      }\n    }\n    this.s += this.diff\n    this.count--\n    return this.s\n  }\n}\n\nexport class StringDecoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    this.decoder = new UintOptRleDecoder(uint8Array)\n    this.str = readVarString(this.decoder)\n    /**\n     * @type {number}\n     */\n    this.spos = 0\n  }\n\n  /**\n   * @return {string}\n   */\n  read () {\n    const end = this.spos + this.decoder.read()\n    const res = this.str.slice(this.spos, end)\n    this.spos = end\n    return res\n  }\n}\n","/**\n * Efficient schema-less binary encoding with support for variable length encoding.\n *\n * Use [lib0/encoding] with [lib0/decoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = new encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, 'Hello world!')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = new decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => 'Hello world!'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module encoding\n */\n\nimport * as buffer from './buffer.js'\nimport * as math from './math.js'\nimport * as number from './number.js'\nimport * as binary from './binary.js'\nimport * as string from './string.js'\n\n/**\n * A BinaryEncoder handles the encoding to an Uint8Array.\n */\nexport class Encoder {\n  constructor () {\n    this.cpos = 0\n    this.cbuf = new Uint8Array(100)\n    /**\n     * @type {Array<Uint8Array>}\n     */\n    this.bufs = []\n  }\n}\n\n/**\n * @function\n * @return {Encoder}\n */\nexport const createEncoder = () => new Encoder()\n\n/**\n * The current length of the encoded data.\n *\n * @function\n * @param {Encoder} encoder\n * @return {number}\n */\nexport const length = encoder => {\n  let len = encoder.cpos\n  for (let i = 0; i < encoder.bufs.length; i++) {\n    len += encoder.bufs[i].length\n  }\n  return len\n}\n\n/**\n * Transform to Uint8Array.\n *\n * @function\n * @param {Encoder} encoder\n * @return {Uint8Array} The created ArrayBuffer.\n */\nexport const toUint8Array = encoder => {\n  const uint8arr = new Uint8Array(length(encoder))\n  let curPos = 0\n  for (let i = 0; i < encoder.bufs.length; i++) {\n    const d = encoder.bufs[i]\n    uint8arr.set(d, curPos)\n    curPos += d.length\n  }\n  uint8arr.set(buffer.createUint8ArrayViewFromArrayBuffer(encoder.cbuf.buffer, 0, encoder.cpos), curPos)\n  return uint8arr\n}\n\n/**\n * Verify that it is possible to write `len` bytes wtihout checking. If\n * necessary, a new Buffer with the required length is attached.\n *\n * @param {Encoder} encoder\n * @param {number} len\n */\nexport const verifyLen = (encoder, len) => {\n  const bufferLen = encoder.cbuf.length\n  if (bufferLen - encoder.cpos < len) {\n    encoder.bufs.push(buffer.createUint8ArrayViewFromArrayBuffer(encoder.cbuf.buffer, 0, encoder.cpos))\n    encoder.cbuf = new Uint8Array(math.max(bufferLen, len) * 2)\n    encoder.cpos = 0\n  }\n}\n\n/**\n * Write one byte to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The byte that is to be encoded.\n */\nexport const write = (encoder, num) => {\n  const bufferLen = encoder.cbuf.length\n  if (encoder.cpos === bufferLen) {\n    encoder.bufs.push(encoder.cbuf)\n    encoder.cbuf = new Uint8Array(bufferLen * 2)\n    encoder.cpos = 0\n  }\n  encoder.cbuf[encoder.cpos++] = num\n}\n\n/**\n * Write one byte at a specific position.\n * Position must already be written (i.e. encoder.length > pos)\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos Position to which to write data\n * @param {number} num Unsigned 8-bit integer\n */\nexport const set = (encoder, pos, num) => {\n  let buffer = null\n  // iterate all buffers and adjust position\n  for (let i = 0; i < encoder.bufs.length && buffer === null; i++) {\n    const b = encoder.bufs[i]\n    if (pos < b.length) {\n      buffer = b // found buffer\n    } else {\n      pos -= b.length\n    }\n  }\n  if (buffer === null) {\n    // use current buffer\n    buffer = encoder.cbuf\n  }\n  buffer[pos] = num\n}\n\n/**\n * Write one byte as an unsigned integer.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeUint8 = write\n\n/**\n * Write one byte as an unsigned Integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nexport const setUint8 = set\n\n/**\n * Write two bytes as an unsigned integer.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeUint16 = (encoder, num) => {\n  write(encoder, num & binary.BITS8)\n  write(encoder, (num >>> 8) & binary.BITS8)\n}\n/**\n * Write two bytes as an unsigned integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nexport const setUint16 = (encoder, pos, num) => {\n  set(encoder, pos, num & binary.BITS8)\n  set(encoder, pos + 1, (num >>> 8) & binary.BITS8)\n}\n\n/**\n * Write two bytes as an unsigned integer\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeUint32 = (encoder, num) => {\n  for (let i = 0; i < 4; i++) {\n    write(encoder, num & binary.BITS8)\n    num >>>= 8\n  }\n}\n\n/**\n * Write two bytes as an unsigned integer in big endian order.\n * (most significant byte first)\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeUint32BigEndian = (encoder, num) => {\n  for (let i = 3; i >= 0; i--) {\n    write(encoder, (num >>> (8 * i)) & binary.BITS8)\n  }\n}\n\n/**\n * Write two bytes as an unsigned integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nexport const setUint32 = (encoder, pos, num) => {\n  for (let i = 0; i < 4; i++) {\n    set(encoder, pos + i, num & binary.BITS8)\n    num >>>= 8\n  }\n}\n\n/**\n * Write a variable length unsigned integer. Max encodable integer is 2^53.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeVarUint = (encoder, num) => {\n  while (num > binary.BITS7) {\n    write(encoder, binary.BIT8 | (binary.BITS7 & num))\n    num = math.floor(num / 128) // shift >>> 7\n  }\n  write(encoder, binary.BITS7 & num)\n}\n\n/**\n * Write a variable length integer.\n *\n * We use the 7th bit instead for signaling that this is a negative number.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeVarInt = (encoder, num) => {\n  const isNegative = math.isNegativeZero(num)\n  if (isNegative) {\n    num = -num\n  }\n  //             |- whether to continue reading         |- whether is negative     |- number\n  write(encoder, (num > binary.BITS6 ? binary.BIT8 : 0) | (isNegative ? binary.BIT7 : 0) | (binary.BITS6 & num))\n  num = math.floor(num / 64) // shift >>> 6\n  // We don't need to consider the case of num === 0 so we can use a different\n  // pattern here than above.\n  while (num > 0) {\n    write(encoder, (num > binary.BITS7 ? binary.BIT8 : 0) | (binary.BITS7 & num))\n    num = math.floor(num / 128) // shift >>> 7\n  }\n}\n\n/**\n * A cache to store strings temporarily\n */\nconst _strBuffer = new Uint8Array(30000)\nconst _maxStrBSize = _strBuffer.length / 3\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\nexport const _writeVarStringNative = (encoder, str) => {\n  if (str.length < _maxStrBSize) {\n    // We can encode the string into the existing buffer\n    /* istanbul ignore else */\n    const written = string.utf8TextEncoder.encodeInto(str, _strBuffer).written || 0\n    writeVarUint(encoder, written)\n    for (let i = 0; i < written; i++) {\n      write(encoder, _strBuffer[i])\n    }\n  } else {\n    writeVarUint8Array(encoder, string.encodeUtf8(str))\n  }\n}\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\nexport const _writeVarStringPolyfill = (encoder, str) => {\n  const encodedString = unescape(encodeURIComponent(str))\n  const len = encodedString.length\n  writeVarUint(encoder, len)\n  for (let i = 0; i < len; i++) {\n    write(encoder, /** @type {number} */ (encodedString.codePointAt(i)))\n  }\n}\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\n/* istanbul ignore next */\nexport const writeVarString = (string.utf8TextEncoder && string.utf8TextEncoder.encodeInto) ? _writeVarStringNative : _writeVarStringPolyfill\n\n/**\n * Write the content of another Encoder.\n *\n * @TODO: can be improved!\n *        - Note: Should consider that when appending a lot of small Encoders, we should rather clone than referencing the old structure.\n *                Encoders start with a rather big initial buffer.\n *\n * @function\n * @param {Encoder} encoder The enUint8Arr\n * @param {Encoder} append The BinaryEncoder to be written.\n */\nexport const writeBinaryEncoder = (encoder, append) => writeUint8Array(encoder, toUint8Array(append))\n\n/**\n * Append fixed-length Uint8Array to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nexport const writeUint8Array = (encoder, uint8Array) => {\n  const bufferLen = encoder.cbuf.length\n  const cpos = encoder.cpos\n  const leftCopyLen = math.min(bufferLen - cpos, uint8Array.length)\n  const rightCopyLen = uint8Array.length - leftCopyLen\n  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos)\n  encoder.cpos += leftCopyLen\n  if (rightCopyLen > 0) {\n    // Still something to write, write right half..\n    // Append new buffer\n    encoder.bufs.push(encoder.cbuf)\n    // must have at least size of remaining buffer\n    encoder.cbuf = new Uint8Array(math.max(bufferLen * 2, rightCopyLen))\n    // copy array\n    encoder.cbuf.set(uint8Array.subarray(leftCopyLen))\n    encoder.cpos = rightCopyLen\n  }\n}\n\n/**\n * Append an Uint8Array to Encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nexport const writeVarUint8Array = (encoder, uint8Array) => {\n  writeVarUint(encoder, uint8Array.byteLength)\n  writeUint8Array(encoder, uint8Array)\n}\n\n/**\n * Create an DataView of the next `len` bytes. Use it to write data after\n * calling this function.\n *\n * ```js\n * // write float32 using DataView\n * const dv = writeOnDataView(encoder, 4)\n * dv.setFloat32(0, 1.1)\n * // read float32 using DataView\n * const dv = readFromDataView(encoder, 4)\n * dv.getFloat32(0) // => 1.100000023841858 (leaving it to the reader to find out why this is the correct result)\n * ```\n *\n * @param {Encoder} encoder\n * @param {number} len\n * @return {DataView}\n */\nexport const writeOnDataView = (encoder, len) => {\n  verifyLen(encoder, len)\n  const dview = new DataView(encoder.cbuf.buffer, encoder.cpos, len)\n  encoder.cpos += len\n  return dview\n}\n\n/**\n * @param {Encoder} encoder\n * @param {number} num\n */\nexport const writeFloat32 = (encoder, num) => writeOnDataView(encoder, 4).setFloat32(0, num, false)\n\n/**\n * @param {Encoder} encoder\n * @param {number} num\n */\nexport const writeFloat64 = (encoder, num) => writeOnDataView(encoder, 8).setFloat64(0, num, false)\n\n/**\n * @param {Encoder} encoder\n * @param {bigint} num\n */\nexport const writeBigInt64 = (encoder, num) => /** @type {any} */ (writeOnDataView(encoder, 8)).setBigInt64(0, num, false)\n\n/**\n * @param {Encoder} encoder\n * @param {bigint} num\n */\nexport const writeBigUint64 = (encoder, num) => /** @type {any} */ (writeOnDataView(encoder, 8)).setBigUint64(0, num, false)\n\nconst floatTestBed = new DataView(new ArrayBuffer(4))\n/**\n * Check if a number can be encoded as a 32 bit float.\n *\n * @param {number} num\n * @return {boolean}\n */\nconst isFloat32 = num => {\n  floatTestBed.setFloat32(0, num)\n  return floatTestBed.getFloat32(0) === num\n}\n\n/**\n * Encode data with efficient binary format.\n *\n * Differences to JSON:\n * • Transforms data to a binary format (not to a string)\n * • Encodes undefined, NaN, and ArrayBuffer (these can't be represented in JSON)\n * • Numbers are efficiently encoded either as a variable length integer, as a\n *   32 bit float, as a 64 bit float, or as a 64 bit bigint.\n *\n * Encoding table:\n *\n * | Data Type           | Prefix   | Encoding Method    | Comment |\n * | ------------------- | -------- | ------------------ | ------- |\n * | undefined           | 127      |                    | Functions, symbol, and everything that cannot be identified is encoded as undefined |\n * | null                | 126      |                    | |\n * | integer             | 125      | writeVarInt        | Only encodes 32 bit signed integers |\n * | float32             | 124      | writeFloat32       | |\n * | float64             | 123      | writeFloat64       | |\n * | bigint              | 122      | writeBigInt64      | |\n * | boolean (false)     | 121      |                    | True and false are different data types so we save the following byte |\n * | boolean (true)      | 120      |                    | - 0b01111000 so the last bit determines whether true or false |\n * | string              | 119      | writeVarString     | |\n * | object<string,any>  | 118      | custom             | Writes {length} then {length} key-value pairs |\n * | array<any>          | 117      | custom             | Writes {length} then {length} json values |\n * | Uint8Array          | 116      | writeVarUint8Array | We use Uint8Array for any kind of binary data |\n *\n * Reasons for the decreasing prefix:\n * We need the first bit for extendability (later we may want to encode the\n * prefix with writeVarUint). The remaining 7 bits are divided as follows:\n * [0-30]   the beginning of the data range is used for custom purposes\n *          (defined by the function that uses this library)\n * [31-127] the end of the data range is used for data encoding by\n *          lib0/encoding.js\n *\n * @param {Encoder} encoder\n * @param {undefined|null|number|bigint|boolean|string|Object<string,any>|Array<any>|Uint8Array} data\n */\nexport const writeAny = (encoder, data) => {\n  switch (typeof data) {\n    case 'string':\n      // TYPE 119: STRING\n      write(encoder, 119)\n      writeVarString(encoder, data)\n      break\n    case 'number':\n      if (number.isInteger(data) && math.abs(data) <= binary.BITS31) {\n        // TYPE 125: INTEGER\n        write(encoder, 125)\n        writeVarInt(encoder, data)\n      } else if (isFloat32(data)) {\n        // TYPE 124: FLOAT32\n        write(encoder, 124)\n        writeFloat32(encoder, data)\n      } else {\n        // TYPE 123: FLOAT64\n        write(encoder, 123)\n        writeFloat64(encoder, data)\n      }\n      break\n    case 'bigint':\n      // TYPE 122: BigInt\n      write(encoder, 122)\n      writeBigInt64(encoder, data)\n      break\n    case 'object':\n      if (data === null) {\n        // TYPE 126: null\n        write(encoder, 126)\n      } else if (data instanceof Array) {\n        // TYPE 117: Array\n        write(encoder, 117)\n        writeVarUint(encoder, data.length)\n        for (let i = 0; i < data.length; i++) {\n          writeAny(encoder, data[i])\n        }\n      } else if (data instanceof Uint8Array) {\n        // TYPE 116: ArrayBuffer\n        write(encoder, 116)\n        writeVarUint8Array(encoder, data)\n      } else {\n        // TYPE 118: Object\n        write(encoder, 118)\n        const keys = Object.keys(data)\n        writeVarUint(encoder, keys.length)\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i]\n          writeVarString(encoder, key)\n          writeAny(encoder, data[key])\n        }\n      }\n      break\n    case 'boolean':\n      // TYPE 120/121: boolean (true/false)\n      write(encoder, data ? 120 : 121)\n      break\n    default:\n      // TYPE 127: undefined\n      write(encoder, 127)\n  }\n}\n\n/**\n * Now come a few stateful encoder that have their own classes.\n */\n\n/**\n * Basic Run Length Encoder - a basic compression implementation.\n *\n * Encodes [1,1,1,7] to [1,3,7,1] (3 times 1, 1 time 7). This encoder might do more harm than good if there are a lot of values that are not repeated.\n *\n * It was originally used for image compression. Cool .. article http://csbruce.com/cbm/transactor/pdfs/trans_v7_i06.pdf\n *\n * @note T must not be null!\n *\n * @template T\n */\nexport class RleEncoder extends Encoder {\n  /**\n   * @param {function(Encoder, T):void} writer\n   */\n  constructor (writer) {\n    super()\n    /**\n     * The writer\n     */\n    this.w = writer\n    /**\n     * Current state\n     * @type {T|null}\n     */\n    this.s = null\n    this.count = 0\n  }\n\n  /**\n   * @param {T} v\n   */\n  write (v) {\n    if (this.s === v) {\n      this.count++\n    } else {\n      if (this.count > 0) {\n        // flush counter, unless this is the first value (count = 0)\n        writeVarUint(this, this.count - 1) // since count is always > 0, we can decrement by one. non-standard encoding ftw\n      }\n      this.count = 1\n      // write first value\n      this.w(this, v)\n      this.s = v\n    }\n  }\n}\n\n/**\n * Basic diff decoder using variable length encoding.\n *\n * Encodes the values [3, 1100, 1101, 1050, 0] to [3, 1097, 1, -51, -1050] using writeVarInt.\n */\nexport class IntDiffEncoder extends Encoder {\n  /**\n   * @param {number} start\n   */\n  constructor (start) {\n    super()\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    writeVarInt(this, v - this.s)\n    this.s = v\n  }\n}\n\n/**\n * A combination of IntDiffEncoder and RleEncoder.\n *\n * Basically first writes the IntDiffEncoder and then counts duplicate diffs using RleEncoding.\n *\n * Encodes the values [1,1,1,2,3,4,5,6] as [1,1,0,2,1,5] (RLE([1,0,0,1,1,1,1,1]) ⇒ RleIntDiff[1,1,0,2,1,5])\n */\nexport class RleIntDiffEncoder extends Encoder {\n  /**\n   * @param {number} start\n   */\n  constructor (start) {\n    super()\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n    this.count = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.s === v && this.count > 0) {\n      this.count++\n    } else {\n      if (this.count > 0) {\n        // flush counter, unless this is the first value (count = 0)\n        writeVarUint(this, this.count - 1) // since count is always > 0, we can decrement by one. non-standard encoding ftw\n      }\n      this.count = 1\n      // write first value\n      writeVarInt(this, v - this.s)\n      this.s = v\n    }\n  }\n}\n\n/**\n * @param {UintOptRleEncoder} encoder\n */\nconst flushUintOptRleEncoder = encoder => {\n  /* istanbul ignore else */\n  if (encoder.count > 0) {\n    // flush counter, unless this is the first value (count = 0)\n    // case 1: just a single value. set sign to positive\n    // case 2: write several values. set sign to negative to indicate that there is a length coming\n    writeVarInt(encoder.encoder, encoder.count === 1 ? encoder.s : -encoder.s)\n    if (encoder.count > 1) {\n      writeVarUint(encoder.encoder, encoder.count - 2) // since count is always > 1, we can decrement by one. non-standard encoding ftw\n    }\n  }\n}\n\n/**\n * Optimized Rle encoder that does not suffer from the mentioned problem of the basic Rle encoder.\n *\n * Internally uses VarInt encoder to write unsigned integers. If the input occurs multiple times, we write\n * write it as a negative number. The UintOptRleDecoder then understands that it needs to read a count.\n *\n * Encodes [1,2,3,3,3] as [1,2,-3,3] (once 1, once 2, three times 3)\n */\nexport class UintOptRleEncoder {\n  constructor () {\n    this.encoder = new Encoder()\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.s === v) {\n      this.count++\n    } else {\n      flushUintOptRleEncoder(this)\n      this.count = 1\n      this.s = v\n    }\n  }\n\n  toUint8Array () {\n    flushUintOptRleEncoder(this)\n    return toUint8Array(this.encoder)\n  }\n}\n\n/**\n * Increasing Uint Optimized RLE Encoder\n *\n * The RLE encoder counts the number of same occurences of the same value.\n * The IncUintOptRle encoder counts if the value increases.\n * I.e. 7, 8, 9, 10 will be encoded as [-7, 4]. 1, 3, 5 will be encoded\n * as [1, 3, 5].\n */\nexport class IncUintOptRleEncoder {\n  constructor () {\n    this.encoder = new Encoder()\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.s + this.count === v) {\n      this.count++\n    } else {\n      flushUintOptRleEncoder(this)\n      this.count = 1\n      this.s = v\n    }\n  }\n\n  toUint8Array () {\n    flushUintOptRleEncoder(this)\n    return toUint8Array(this.encoder)\n  }\n}\n\n/**\n * @param {IntDiffOptRleEncoder} encoder\n */\nconst flushIntDiffOptRleEncoder = encoder => {\n  if (encoder.count > 0) {\n    //          31 bit making up the diff | wether to write the counter\n    // const encodedDiff = encoder.diff << 1 | (encoder.count === 1 ? 0 : 1)\n    const encodedDiff = encoder.diff * 2 + (encoder.count === 1 ? 0 : 1)\n    // flush counter, unless this is the first value (count = 0)\n    // case 1: just a single value. set first bit to positive\n    // case 2: write several values. set first bit to negative to indicate that there is a length coming\n    writeVarInt(encoder.encoder, encodedDiff)\n    if (encoder.count > 1) {\n      writeVarUint(encoder.encoder, encoder.count - 2) // since count is always > 1, we can decrement by one. non-standard encoding ftw\n    }\n  }\n}\n\n/**\n * A combination of the IntDiffEncoder and the UintOptRleEncoder.\n *\n * The count approach is similar to the UintDiffOptRleEncoder, but instead of using the negative bitflag, it encodes\n * in the LSB whether a count is to be read. Therefore this Encoder only supports 31 bit integers!\n *\n * Encodes [1, 2, 3, 2] as [3, 1, 6, -1] (more specifically [(1 << 1) | 1, (3 << 0) | 0, -1])\n *\n * Internally uses variable length encoding. Contrary to normal UintVar encoding, the first byte contains:\n * * 1 bit that denotes whether the next value is a count (LSB)\n * * 1 bit that denotes whether this value is negative (MSB - 1)\n * * 1 bit that denotes whether to continue reading the variable length integer (MSB)\n *\n * Therefore, only five bits remain to encode diff ranges.\n *\n * Use this Encoder only when appropriate. In most cases, this is probably a bad idea.\n */\nexport class IntDiffOptRleEncoder {\n  constructor () {\n    this.encoder = new Encoder()\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n    this.diff = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.diff === v - this.s) {\n      this.s = v\n      this.count++\n    } else {\n      flushIntDiffOptRleEncoder(this)\n      this.count = 1\n      this.diff = v - this.s\n      this.s = v\n    }\n  }\n\n  toUint8Array () {\n    flushIntDiffOptRleEncoder(this)\n    return toUint8Array(this.encoder)\n  }\n}\n\n/**\n * Optimized String Encoder.\n *\n * Encoding many small strings in a simple Encoder is not very efficient. The function call to decode a string takes some time and creates references that must be eventually deleted.\n * In practice, when decoding several million small strings, the GC will kick in more and more often to collect orphaned string objects (or maybe there is another reason?).\n *\n * This string encoder solves the above problem. All strings are concatenated and written as a single string using a single encoding call.\n *\n * The lengths are encoded using a UintOptRleEncoder.\n */\nexport class StringEncoder {\n  constructor () {\n    /**\n     * @type {Array<string>}\n     */\n    this.sarr = []\n    this.s = ''\n    this.lensE = new UintOptRleEncoder()\n  }\n\n  /**\n   * @param {string} string\n   */\n  write (string) {\n    this.s += string\n    if (this.s.length > 19) {\n      this.sarr.push(this.s)\n      this.s = ''\n    }\n    this.lensE.write(string.length)\n  }\n\n  toUint8Array () {\n    const encoder = new Encoder()\n    this.sarr.push(this.s)\n    this.s = ''\n    writeVarString(encoder, this.sarr.join(''))\n    writeUint8Array(encoder, this.lensE.toUint8Array())\n    return toUint8Array(encoder)\n  }\n}\n","/**\n * Often used conditions.\n *\n * @module conditions\n */\n\n/**\n * @template T\n * @param {T|null|undefined} v\n * @return {T|null}\n */\n/* istanbul ignore next */\nexport const undefinedToNull = v => v === undefined ? null : v\n","/**\n * Isomorphic module to work access the environment (query params, env variables).\n *\n * @module map\n */\n\nimport * as map from './map.js'\nimport * as string from './string.js'\nimport * as conditions from './conditions.js'\nimport * as storage from './storage.js'\nimport * as f from './function.js'\n\n/* istanbul ignore next */\n// @ts-ignore\nexport const isNode = typeof process !== 'undefined' && process.release &&\n  /node|io\\.js/.test(process.release.name)\n/* istanbul ignore next */\nexport const isBrowser = typeof window !== 'undefined' && !isNode\n/* istanbul ignore next */\nexport const isMac = typeof navigator !== 'undefined'\n  ? /Mac/.test(navigator.platform)\n  : false\n\n/**\n * @type {Map<string,string>}\n */\nlet params\nconst args = []\n\n/* istanbul ignore next */\nconst computeParams = () => {\n  if (params === undefined) {\n    if (isNode) {\n      params = map.create()\n      const pargs = process.argv\n      let currParamName = null\n      /* istanbul ignore next */\n      for (let i = 0; i < pargs.length; i++) {\n        const parg = pargs[i]\n        if (parg[0] === '-') {\n          if (currParamName !== null) {\n            params.set(currParamName, '')\n          }\n          currParamName = parg\n        } else {\n          if (currParamName !== null) {\n            params.set(currParamName, parg)\n            currParamName = null\n          } else {\n            args.push(parg)\n          }\n        }\n      }\n      if (currParamName !== null) {\n        params.set(currParamName, '')\n      }\n      // in ReactNative for example this would not be true (unless connected to the Remote Debugger)\n    } else if (typeof location === 'object') {\n      params = map.create(); // eslint-disable-next-line no-undef\n      (location.search || '?').slice(1).split('&').forEach((kv) => {\n        if (kv.length !== 0) {\n          const [key, value] = kv.split('=')\n          params.set(`--${string.fromCamelCase(key, '-')}`, value)\n          params.set(`-${string.fromCamelCase(key, '-')}`, value)\n        }\n      })\n    } else {\n      params = map.create()\n    }\n  }\n  return params\n}\n\n/**\n * @param {string} name\n * @return {boolean}\n */\n/* istanbul ignore next */\nexport const hasParam = (name) => computeParams().has(name)\n\n/**\n * @param {string} name\n * @param {string} defaultVal\n * @return {string}\n */\n/* istanbul ignore next */\nexport const getParam = (name, defaultVal) =>\n  computeParams().get(name) || defaultVal\n// export const getArgs = name => computeParams() && args\n\n/**\n * @param {string} name\n * @return {string|null}\n */\n/* istanbul ignore next */\nexport const getVariable = (name) =>\n  isNode\n    ? conditions.undefinedToNull(process.env[name.toUpperCase()])\n    : conditions.undefinedToNull(storage.varStorage.getItem(name))\n\n/**\n * @param {string} name\n * @return {string|null}\n */\nexport const getConf = (name) =>\n  computeParams().get('--' + name) || getVariable(name)\n\n/**\n * @param {string} name\n * @return {boolean}\n */\n/* istanbul ignore next */\nexport const hasConf = (name) =>\n  hasParam('--' + name) || getVariable(name) !== null\n\n/* istanbul ignore next */\nexport const production = hasConf('production')\n\n/* istanbul ignore next */\nconst forceColor = isNode &&\n  f.isOneOf(process.env.FORCE_COLOR, ['true', '1', '2'])\n\n/* istanbul ignore next */\nexport const supportsColor = !hasParam('no-colors') &&\n  (!isNode || process.stdout.isTTY || forceColor) && (\n  !isNode || hasParam('color') || forceColor ||\n    getVariable('COLORTERM') !== null ||\n    (getVariable('TERM') || '').includes('color')\n)\n","/**\n * Utility helpers for working with numbers.\n *\n * @module number\n */\n\nimport * as math from './math.js'\nimport * as binary from './binary.js'\n\nexport const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER\nexport const MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER\n\nexport const LOWEST_INT32 = 1 << 31\n/**\n * @type {number}\n */\nexport const HIGHEST_INT32 = binary.BITS31\n\n/**\n * @module number\n */\n\n/* istanbul ignore next */\nexport const isInteger = Number.isInteger || (num => typeof num === 'number' && isFinite(num) && math.floor(num) === num)\nexport const isNaN = Number.isNaN\nexport const parseInt = Number.parseInt\n","/* global localStorage, addEventListener */\n\n/**\n * Isomorphic variable storage.\n *\n * Uses LocalStorage in the browser and falls back to in-memory storage.\n *\n * @module storage\n */\n\n/* istanbul ignore next */\nclass VarStoragePolyfill {\n  constructor () {\n    this.map = new Map()\n  }\n\n  /**\n   * @param {string} key\n   * @param {any} newValue\n   */\n  setItem (key, newValue) {\n    this.map.set(key, newValue)\n  }\n\n  /**\n   * @param {string} key\n   */\n  getItem (key) {\n    return this.map.get(key)\n  }\n}\n\n/* istanbul ignore next */\n/**\n * @type {any}\n */\nlet _localStorage = new VarStoragePolyfill()\nlet usePolyfill = true\n\ntry {\n  // if the same-origin rule is violated, accessing localStorage might thrown an error\n  /* istanbul ignore next */\n  if (typeof localStorage !== 'undefined') {\n    _localStorage = localStorage\n    usePolyfill = false\n  }\n} catch (e) { }\n\n/* istanbul ignore next */\n/**\n * This is basically localStorage in browser, or a polyfill in nodejs\n */\nexport const varStorage = _localStorage\n\n/* istanbul ignore next */\n/**\n * A polyfill for `addEventListener('storage', event => {..})` that does nothing if the polyfill is being used.\n *\n * @param {function({ key: string, newValue: string, oldValue: string }): void} eventHandler\n * @function\n */\nexport const onChange = eventHandler => usePolyfill || addEventListener('storage', /** @type {any} */ (eventHandler))\n","/**\n * Utility module to work with strings.\n *\n * @module string\n */\n\nexport const fromCharCode = String.fromCharCode\nexport const fromCodePoint = String.fromCodePoint\n\n/**\n * @param {string} s\n * @return {string}\n */\nconst toLowerCase = s => s.toLowerCase()\n\nconst trimLeftRegex = /^\\s*/g\n\n/**\n * @param {string} s\n * @return {string}\n */\nexport const trimLeft = s => s.replace(trimLeftRegex, '')\n\nconst fromCamelCaseRegex = /([A-Z])/g\n\n/**\n * @param {string} s\n * @param {string} separator\n * @return {string}\n */\nexport const fromCamelCase = (s, separator) => trimLeft(s.replace(fromCamelCaseRegex, match => `${separator}${toLowerCase(match)}`))\n\n/**\n * Compute the utf8ByteLength\n * @param {string} str\n * @return {number}\n */\nexport const utf8ByteLength = str => unescape(encodeURIComponent(str)).length\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\nexport const _encodeUtf8Polyfill = str => {\n  const encodedString = unescape(encodeURIComponent(str))\n  const len = encodedString.length\n  const buf = new Uint8Array(len)\n  for (let i = 0; i < len; i++) {\n    buf[i] = /** @type {number} */ (encodedString.codePointAt(i))\n  }\n  return buf\n}\n\n/* istanbul ignore next */\nexport const utf8TextEncoder = /** @type {TextEncoder} */ (typeof TextEncoder !== 'undefined' ? new TextEncoder() : null)\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\nexport const _encodeUtf8Native = str => utf8TextEncoder.encode(str)\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\n/* istanbul ignore next */\nexport const encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill\n\n/**\n * @param {Uint8Array} buf\n * @return {string}\n */\nexport const _decodeUtf8Polyfill = buf => {\n  let remainingLen = buf.length\n  let encodedString = ''\n  let bufPos = 0\n  while (remainingLen > 0) {\n    const nextLen = remainingLen < 10000 ? remainingLen : 10000\n    const bytes = buf.subarray(bufPos, bufPos + nextLen)\n    bufPos += nextLen\n    // Starting with ES5.1 we can supply a generic array-like object as arguments\n    encodedString += String.fromCodePoint.apply(null, /** @type {any} */ (bytes))\n    remainingLen -= nextLen\n  }\n  return decodeURIComponent(escape(encodedString))\n}\n\n/* istanbul ignore next */\nexport let utf8TextDecoder = typeof TextDecoder === 'undefined' ? null : new TextDecoder('utf-8', { fatal: true, ignoreBOM: true })\n\n/* istanbul ignore next */\nif (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array()).length === 1) {\n  // Safari doesn't handle BOM correctly.\n  // This fixes a bug in Safari 13.0.5 where it produces a BOM the first time it is called.\n  // utf8TextDecoder.decode(new Uint8Array()).length === 1 on the first call and\n  // utf8TextDecoder.decode(new Uint8Array()).length === 1 on the second call\n  // Another issue is that from then on no BOM chars are recognized anymore\n  /* istanbul ignore next */\n  utf8TextDecoder = null\n}\n\n/**\n * @param {Uint8Array} buf\n * @return {string}\n */\nexport const _decodeUtf8Native = buf => /** @type {TextDecoder} */ (utf8TextDecoder).decode(buf)\n\n/**\n * @param {Uint8Array} buf\n * @return {string}\n */\n/* istanbul ignore next */\nexport const decodeUtf8 = utf8TextDecoder ? _decodeUtf8Native : _decodeUtf8Polyfill\n\n/**\n * @param {string} str The initial string\n * @param {number} index Starting position\n * @param {number} remove Number of characters to remove\n * @param {string} insert New content to insert\n */\nexport const splice = (str, index, remove, insert = '') => str.slice(0, index) + insert + str.slice(index + remove)\n","/**\n * Utility module to work with time.\n *\n * @module time\n */\n\nimport * as metric from './metric.js'\nimport * as math from './math.js'\n\n/**\n * Return current time.\n *\n * @return {Date}\n */\nexport const getDate = () => new Date()\n\n/**\n * Return current unix time.\n *\n * @return {number}\n */\nexport const getUnixTime = Date.now\n\n/**\n * Transform time (in ms) to a human readable format. E.g. 1100 => 1.1s. 60s => 1min. .001 => 10μs.\n *\n * @param {number} d duration in milliseconds\n * @return {string} humanized approximation of time\n */\nexport const humanizeDuration = d => {\n  if (d < 60000) {\n    const p = metric.prefix(d, -1)\n    return math.round(p.n * 100) / 100 + p.prefix + 's'\n  }\n  d = math.floor(d / 1000)\n  const seconds = d % 60\n  const minutes = math.floor(d / 60) % 60\n  const hours = math.floor(d / 3600) % 24\n  const days = math.floor(d / 86400)\n  if (days > 0) {\n    return days + 'd' + ((hours > 0 || minutes > 30) ? ' ' + (minutes > 30 ? hours + 1 : hours) + 'h' : '')\n  }\n  if (hours > 0) {\n    /* istanbul ignore next */\n    return hours + 'h' + ((minutes > 0 || seconds > 30) ? ' ' + (seconds > 30 ? minutes + 1 : minutes) + 'min' : '')\n  }\n  return minutes + 'min' + (seconds > 0 ? ' ' + seconds + 's' : '')\n}\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n"],"sourceRoot":""}